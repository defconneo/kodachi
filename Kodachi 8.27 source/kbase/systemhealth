#!/bin/bash
# Script written by Warith Al Maawali  
# (c) 2022 Founder of Eagle Eye Digital Solutions
# Discord channel https://discord.gg/KEFErEx
# Twitter http://twitter.com/warith2020
# Linkedin http://www.linkedin.com/in/warith1977
# http://www.digi77.com
# http://www.om77.net
# Kodachi  OS/Software/Code are strictly protected by LICENSE terms at /home/kodachi/LICENSE
#
#
# script starts here:


# Testing and examples
#sudo -H -u kodachi bash -c 'echo $HOME' > $Myhome_path/Desktop/t.txt

#Cheatsheet:

#Read from json
#netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);

# Unix / Linux - Shell Basic Operators
#https://www.tutorialspoint.com/unix/unix-basic-operators.htm

 #-eq # equal
#-ne # not equal
#-lt # less than
#-le # less than or equal
#-gt # greater than
#-ge # greater than or equal


#A; B    # Run A and then B, regardless of success of A
#A && B  # Run B if and only if A succeeded
#A || B  # Run B if and only if A failed
#A &     # Run A in background.

# Pass output and excute it examples
# cat workingdomain.txt |xargs -n1 curl -t 15
# find /path -type f | while read ln; do echo "processing $ln"; done
# echo "input" | awk '{print $1"string"}

#Refrence
#Yes, to comment line containing specific string with sed, simply do:
#sed -i '/<pattern>/s/^/#/g' file

#And to uncomment it:
#sed -i '/<pattern>/s/^#//g' file

#nolapic
#noapic
#acpi_osi=“Linux”
#acpi_osi=“Windows 2006”
#acpi=ht
#pci=noacpi
#acpi=noirq
#pnpacpi=off
#acpi=off


#only if run by system cron  
#export DISPLAY=:0.0 && export XAUTHORITY=$Myhome_path/.Xauthority && sudo -u kodachi /usr/bin/notify-send Sorry! "You have been banned from our network please contact support@digi77.com"
#export DISPLAY=:0.0 && export XAUTHORITY=$Myhome_path/.Xauthority && sudo -u kodachi /usr/bin/conky -c $Mykodachi_path/.conkyrc4;

#Refrence update ip DB
#cd /usr/share/geoip
#wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz || { echo 'Could not download GeoLiteCountry, exiting.' ; exit 1; }
#wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz || { echo 'Could not download GeoLiteCity, exiting.' ; exit 1; }
#gunzip -f GeoIP.dat.gz
#gunzip -f GeoLiteCity.dat.gz
#echo "y"|mv GeoLiteCity.dat GeoIPCity.dat


# REf
#Check if system installed

# Old method of checkeing seed file now i replaced it with user id check dist back! 
#theFile="$Mykodachi_path/persistent";
#pFile="/cdrom/preseed/custom.seed";
#if [ -e "$pFile" ]
#then
	#if !(grep -q kodachi "$pFile"); then
		#echo   "Yes"  > $theFile;
	  
	#else
		#echo   "No"  > $theFile;
	#fi
#else
#	echo   "Yes"  > $theFile;
#fi


#apt stuff
#sudo apt-get purge --auto-remove thermald
#sudo apt rdepends thermald

#cheat sheet
#sudo kill -9 `ps -ef | grep normalspeed | grep -v grep | awk '{print $2}'`
#sudo bash systemhealth normalspeed

# Not used 
#sudo kill -9 `ps -ef | grep hardworknonet | grep -v grep | awk '{print $2}'`
#sudo bash systemhealth -a hardworknonet


#sudo kill -9 `ps -ef | grep dns_control | grep -v grep | awk '{print $2}'`
#sudo bash dns_control


#sudo kill -9 `ps -ef | grep reschangecheck | grep -v grep | awk '{print $2}'`
#bash reschangecheck

#sudo kill -9 `ps -ef | grep bootguicairo | grep -v grep | awk '{print $2}'`
#bash bootguicairo

#sudo kill -9 `ps -ef | grep bootguiconky | grep -v grep | awk '{print $2}'`
#bash bootguiconky

#sudo kill -9 `ps -ef | grep networkboot | grep -v grep | awk '{print $2}'`
#sudo bash networkboot


#sudo kill -9 `ps -ef | grep setsudo | grep -v grep | awk '{print $2}'`
#sudo bash setsudo

#sudo kill -9 `ps -ef | grep conky | grep -v grep | awk '{print $2}'`

 
#sudo kill -9 `ps -ef | grep torifysystem | grep -v grep | awk '{print $2}'`





 
cd $(dirname $0) 
source Globalconfig;



# Set global;
# sets
unset ISP_IP;
unset VPN_IP;
unset TOR_IP;
unset TORRIFY_IP;
unset permenet_ISP_IP;
unset permenet_VPN_IP;
unset permenet_TOR_IP;
unset permenet_TORRIFY_IP;
unset ISP_Country;
unset VPN_Country;
unset TOR_Country;
unset TORRIFY_Country;
unset toriffy_Status;
unset securityScore;       
unset theModel;
unset check_n_files;
unset e;
unset randomdomain;
unset actionpickervalue;
unset theIPcounter;
unset securityStatus;
unset Ban_Status;
unset run_tor_if_vpn_is_off;
unset bTota;
unset kodachinodes;
#unset kodachiipcheck;
unset kodachiban;
unset kodachiremoteupdatesurldir;
unset kodachiremoteupdatesurl;
unset isactive;
unset version;
unset product;
unset tornullipcounter;
unset COuntryCode;
unset rand;
unset TorCon;
unset appName;
unset jsonvarName;
unset param1;
unset param2;
unset holdTimer;

# Assign Vars

tempjqdash="-";
kodachi_version=$Kodachi_version;
domainsFile="$Mykodachi_path/workingdomain.txt";



# Counters:

sameipCounter=0;
killVPNTorcounterpopup=0;
tornullipcounter=0;
securityScore=0;
check_n_files=0;
holdTimer=0;
appName="Sphere";
jsonvarName="spheretor";


#arr[0]="ch";
#arr[1]="be";
#arr[2]="nl";
#arr[3]="pl";
#arr[4]="it";
#arr[5]="at";
#arr[6]="jp";

arr[0]="ch";
arr[1]="at";
arr[2]="lu";
arr[3]="ro";
arr[4]="sc";
arr[5]="pl";
arr[6]="cz";
arr[7]="za";
arr[8]="kr";
arr[9]="jp";
arr[10]="th";
arr[11]="br";
arr[12]="is";
arr[13]="ru";
arr[14]="ua";
arr[15]="md";
arr[16]="bz";
arr[17]="hu";
arr[18]="bg";
arr[19]="sg";
arr[20]="fi";
arr[21]="tr";



# root access check


# If no su privileges available, try to get them
if [[ ! "$(whoami)" == "root" ]] ; then
	
	# No sudo available? Then we can't get su privs. Advise and exit
	if [[ $(which sudo) == "" ]] ; then
		echo "'sudo' package missing! Please install."
		echo "e.g.: apt-get install sudo" 
		exit 1
	fi

	echo "Requesting su permissions..."
	# Run this script with sudo privs
	sudo $0 $*
		# If running this script with su privs failed, advise to do so manually and exit
		if [[ $? > 0 ]] ; then
		echo
		print_error "Acquiring su permission failed!"
		print_error "Please run this script with sudo permissions!"
		print_error "(e.g. 'sudo $0' or 'sudo bash $0')"
		echo
		exit 1
	fi
exit 0
fi

 

# detect empty arguments
if [ $# -eq 0 ]; then
	print_error "No arguments entered"

fi


# Get paramters
param1=$1;
param2=$2;






#Set of functions


 

function getID()
{
    
    fakeid_Status=$(cat $Jason_file_name | jq -r .jfakeidr);
	if [[ "$fakeid_Status" == *Yes* ]]
	then	
		# Fake id
		f1=$(cat /dev/urandom | tr -dc 'a-za-z0-9' | fold -w 32 | head -n 1)
		f2=$(md5sum <<<$f1| tr -d -|tr -d ' ');
		writeToJason "$f2" "kodachihwid";
    else
		a=$(sudo dmidecode -s system-uuid);
		b=$(sudo dmidecode -s system-serial-number);
		c=$(sudo dmidecode |grep -w ID:|head -n1);
		d=$a.$b.$c;
		f=$(md5sum <<<$d| tr -d -|tr -d ' ');
	    g=$(echo $f | cut -d ' ' -f 1);
		e=$g;
		writeToJason "$e" "kodachihwid";  
    fi     
   
}

function getMem()
{
	 
	hw_mem=0
	free_mem=0
	human=1024
	mem_info=$(</proc/meminfo)
	mem_info=$(echo $(echo $(mem_info=${mem_info// /}; echo ${mem_info//kB/})))
		
	for m in $mem_info; do
		if [[ ${m//:*} = MemTotal ]]; then
			memtotal=${m//*:}
		fi

		if [[ ${m//:*} = MemFree ]]; then
			memfree=${m//*:}
		fi

		if [[ ${m//:*} = Buffers ]]; then
			membuffer=${m//*:}
		fi

		if [[ ${m//:*} = Cached ]]; then
			memcached=${m//*:}
		fi			
	done

	usedmem="$(((($memtotal - $memfree) - $membuffer - $memcached) / $human))"
	totalmem="$(($memtotal / $human))"
	mem="${usedmem}M / ${totalmem}M"
	writeToJason "$mem" "memoryused";  
	
}	


function getBan()
{
    getID
    kodachiban=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachiban'|xargs);
    Ban_Status=$(sudo curl -G -s -m 30 "$kodachiban" --data-urlencode "ko_hwid=$e" --data-urlencode "ko_ver=$kodachi_version");
    temp_ban=$(echo $Ban_Status | cut -d ' ' -f 1);
    Ban_Status=$temp_ban;
    writeToJason "$Ban_Status" "banstatus";  
    
}

function banAction()
{
    
    SERVICE='openvpn';
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
	then
		sudo killall -SIGINT openvpn;
		  
	fi
    
    SERVICE='tor-service';
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)		 
	then
		sudo killall tor; 
    fi
    
    resetipsall;
    #resetalljson;	# no need as some like open files boot mode won't be called again
	
	writeToJason "$Ban_Status" "banstatus";  
	writeToJason "No" "TORonifVPNisoff"; 
	writeToJason "Disabled" "VPNtype";  
	
	dnsname="Fail-safe";
	writeToJason "$dnsname" "DNSprovider"; 		
	
	sudo service dnscrypt-proxy stop;  	
    
    notify-send -t 30000 -i $notifyIcon "Bad News!: You have been banned from $OS_name VPN network 
please request for unban within #abuse-records channel on Discord";
    sleep 10;
    #sudo -H -u $LOGED_USER firefox "https://discord.gg/KEFErEx"; # may leak your ip 
    
}








function reset_ISP_IP()
{
	unset permenet_ISP_IP;
	unset ISP_IP;
	unset ISP_Country;
	writeToJason "$tempjqdash" "OriginalISPIPAddress";
	writeToJason "$tempjqdash" "OriginalISPCountry";	
}


function reset_VPN_IP()
{
	
	unset permenet_VPN_IP;
    unset VPN_IP;
	unset VPN_Country;	
	writeToJason "$tempjqdash" "vpnTime";
	writeToJason "$tempjqdash" "VPNIP";
	writeToJason "$tempjqdash" "VPNCountry";
	securityStatus="notsecure";	
	writeToJason "$tempjqdash" "SecurityStatus";
}


function reset_TOR_IP()
{
 
	unset permenet_TOR_IP;
    unset permenet_TORRIFY_IP;	
	unset TOR_IP;
    unset TOR_Country;
    unset TORRIFY_IP;
    unset TORRIFY_Country;
	writeToJason "$tempjqdash" "TORIP";
	writeToJason "$tempjqdash" "TORCountry";
	writeToJason "$tempjqdash" "TORRIFYIP";
	writeToJason "$tempjqdash" "TORRIFYCountry";
}


function resetipsall()
{
	reset_ISP_IP;
	reset_VPN_IP;
	reset_TOR_IP;
}



function getCountry()
{
	thepassedipUsed=$1;
	theCountrytype=$2;
	theCountryKillCounter=0;
	theCountry=$(geoiplookup $thepassedipUsed|cut -d : -f 2|cut -d , -f 2|sed 's/^ *//;s/ *$//'|tail -n 1);	
	
	if [[ -n $thepassedipUsed ]] && [[ -n $theCountrytype ]]
	then
	
		if [[ $theCountrytype == *"VPNStartCountryResolve"* ]]
			then		
				theCountry=$theCountry;
			elif [[ $theCountrytype == *"ISPCountryResolve"* ]]
			then
				ISP_Country=$theCountry; 
			elif [[ $theCountrytype == *"VPNCountryResolve"* ]]
			then
				VPN_Country=$theCountry;
			elif [[ $theCountrytype == *"TORCountryReolve"* ]] 
			then
				TOR_Country=$theCountry;
			elif [[ $theCountrytype == *"TORIFFYCountryReolve"* ]] 
			then
				TORRIFY_Country=$theCountry;
		fi
		
		netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
		if [[ $netStatustxt == *Online* ]]
		then
		
			# Trouble shoot comment later
			#notify-send -t 30000 -i $notifyIcon  "Before loop ip: $thepassedipUsed theCountrytype=$theCountrytype thecountry=$theCountry";
			print_good "Before loop ip: $thepassedipUsed theCountrytype=$theCountrytype thecountry=$theCountry";
			while [[ "$theCountry" == *"not found"* ]] || [[ ! -n $theCountry ]] || [[ "$theCountry" == *"null"* ]]; do				
				
				# Get ip country
				unset arr2;
				unset randomURL;
				unset rand;
				unset template;
				unset jqparm;
				unset dO;
				
				toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
				if [[ "$toriffy_Status" == *Yes* ]]
				then	
					arr2=( $(cat $Jason_web_file_name | jq -r '.ServerFeed4.iGgeoDomains[]') );
				else
					arr2=( $(cat $Jason_web_file_name | jq -r '.ServerFeed5.iGgeoDomainsCF[]') );
				fi
				if [[ -n $arr2 ]]
				then
					rand=$[$RANDOM % ${#arr2[@]}];
				fi
				randomURL=${arr2[$rand]};
				echo ""; 		
				print_good "Random Country from VPN_Country section ip $randomURL";
				
				template=$(echo $randomURL | sed 's/###/'$thepassedipUsed'/g');
				jqparm=$(echo $template|cut -d @ -f 2 );
				template=$(echo $randomURL | sed 's/###/'$thepassedipUsed'/g'|cut -d @ -f 1);
				
				# Get domain only
				dO=$( echo $randomURL | sed -e 's|^[^/]*//||' -e 's|/.*$||');
				
				print_good "Reporting your Country VPN_Country Section from $dO :";
				
				if [[ $theCountrytype == *"VPNStartCountryResolve"* ]]
				then
				
					theCountry=$(curl -s -m 20 -X GET "$template" -H  "accept: application/json" | jq -r $jqparm);
					#sleep 1;
					theCountryKillCounter=$((theCountryKillCounter+1));    
					if [ $theCountryKillCounter -gt 5 ]; then
						echo "Breaking country loop counter =$theCountryKillCounter";
						theCountry="Unresolved";
					fi
				elif [[ $theCountrytype == *"ISPCountryResolve"* ]]
				then
					theCountry=$(curl -s -m 20 -X GET "$template" -H  "accept: application/json" | jq -r $jqparm);
					ISP_Country=$theCountry;
					#sleep 1;
					theCountryKillCounter=$((theCountryKillCounter+1));    
					if [ $theCountryKillCounter -gt 5 ]; then
						echo "Breaking country loop counter =$theCountryKillCounter";
						ISP_Country="Unresolved";
						theCountry="Unresolved";
					fi
				elif [[ $theCountrytype == *"VPNCountryResolve"* ]]
				then
					theCountry=$(curl -s -m 20 -X GET "$template" -H  "accept: application/json" | jq -r $jqparm);
					VPN_Country=$theCountry;
					#sleep 1;
					theCountryKillCounter=$((theCountryKillCounter+1));    
					if [ $theCountryKillCounter -gt 5 ]; then
						echo "Breaking country loop counter =$theCountryKillCounter";
						VPN_Country="Unresolved";
						theCountry="Unresolved";
					fi
				elif [[ $theCountrytype == *"TORCountryReolve"* ]] 
				then
					theCountry=$(curl -s -m 20 -X GET "$template" -H  "accept: application/json" | jq -r $jqparm);
					TOR_Country=$theCountry;
					#sleep 1;
					theCountryKillCounter=$((theCountryKillCounter+1));    
					if [ $theCountryKillCounter -gt 5 ]; then
						echo "Breaking country loop counter =$theCountryKillCounter";
						TOR_Country="Unresolved";
						theCountry="Unresolved";
					fi
				elif [[ $theCountrytype == *"TORIFFYCountryReolve"* ]] 
				then
					theCountry=$(curl -s -m 20 -X GET "$template" -H  "accept: application/json" | jq -r $jqparm);
					TORRIFY_Country=$theCountry;
					#sleep 1;
					theCountryKillCounter=$((theCountryKillCounter+1));    
					if [ $theCountryKillCounter -gt 5 ]; then
						echo "Breaking country loop counter =$theCountryKillCounter";
						TORRIFY_Country="Unresolved";
						theCountry="Unresolved";
					fi
				fi
				
			# Trouble shoot comment later	
			#notify-send -t 30000 -i $notifyIcon  "Inside loop ip: $thepassedipUsed theCountrytype=$theCountrytype thecountry=$theCountry";	
			print_good "Inside loop ip: $thepassedipUsed theCountrytype=$theCountrytype thecountry=$theCountry";
			done
		fi	
		# Trouble shoot comment later
		#notify-send -t 30000 -i $notifyIcon  "AFTER loop ip: $thepassedipUsed theCountrytype=$theCountrytype thecountry=$theCountry";	
		print_good "AFTER loop ip: $thepassedipUsed theCountrytype=$theCountrytype thecountry=$theCountry";
	fi
	
}




function startvpnfunction()
{
   
    SERVICE='openvpn';
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
	then
	    
	 	SERVICE2='riseup-vpn';    
	    if (ps ax | grep -v grep | grep $SERVICE2 > /dev/null)
		then
			sudo killall riseup-vpn;
			sleep 1;
			timeout 2 sudo riseup-vpn -start-vpn off;
			sleep 1;
			sudo killall riseup-vpn ;
			sleep 1;
		fi
	    
	    echo "novpn command received I will stop vpn type:$vpntype";	 
		sudo killall -SIGINT openvpn;
		notify-send -i $notifyIcon "VPN is shutdown"; 	        
        reset_VPN_IP;
    fi    
        
	# Change mac ops
	changeMacStatus=$(cat $Jason_file_name | jq -r .autospoofmac);
	if [[ $changeMacStatus == *Yes* ]]
	then
		bash $Mykodachi_path/gambasexec changeallmac;
	    notify-send -i $notifyIcon "Spoofing MAC's"; 
	fi
	
	sleep 1;
	
    vpntype=$(cat $Jason_file_name | jq -r .VPNtype);
    toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
	netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
	netStatustxtDomainOnly=$(cat $Jason_file_name | jq -r .InternetStatusbydomainonly);
	if [[ $netStatustxt == *Online* ]] && [[ $netStatustxtDomainOnly == *Online* ]]
	then
		
		# kill TOR if we are connecting to new VPN session
	    run_tor_if_vpn_is_off=$(cat $Jason_file_name | jq -r .TORonifVPNisoff);
		if [[ "$run_tor_if_vpn_is_off" == *No* ]]
		then
			SERVICE='tor-service';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)			
			then
				print_good "Stopping TOR because we are entering VPN start function";
				sudo /etc/init.d/tor stop; 
			fi
		fi	
	
		
		if [[ "$toriffy_Status" == *Yes* ]]
		then
			notify-send -i $notifyIcon "VPN over Tor  (ISP > TOR > VPN) is considered to be dangerous please disable system toriffy
Before connecting to VPN then check Kodachi website for more information about this";
			sleep 2;
			sudo bash $Mykodachi_path/stoptor;
			sleep 5;
		fi
		
		
		dns_provider=$(cat $Jason_file_name | jq -r .DNSprovider);
		if [[ "$dns_provider" == TOR ]]
		then
			notify-send -i $notifyIcon "Disabling TOR DNS please turn TOR DNS on again once VPN is established";
		    writeToJason "Quad9Un" "DNSprovider";
		fi
		
		# Kodachi VPN starts here
		if [[ "$vpntype" == Kodachi ]]
		then
			reset_VPN_IP;
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				echo "#### Will kill vpn now before starting it ####";
				sudo killall -SIGINT openvpn;			    
			fi	
					 
		     
			getID;
			sudo echo -n "kodachi|" > /etc/openvpn/auth
			sudo echo $e | cut -d ' ' -f 1 >> /etc/openvpn/auth;	
			sudo echo "cf90b117a31e7c2bb53cac3186b867b0" >> /etc/openvpn/auth;	
			kodachinodes=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachinodes'|xargs);
			if(sudo timeout 60 wget "$kodachinodes" -q)
			then
				sudo rm -f /etc/openvpn/kodachi-vpn.ovpn
				7z x *vpn*.zip -pa30@06e61-79-34-88-A4-C3@ -o/etc/openvpn/ -y &> /dev/null;
				rm -f *kodachi-vpn* 

				#Get proto  port ip
				theOvfile="/etc/openvpn/kodachi-vpn.ovpn";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";  
				
				sudo openvpn --daemon --config /etc/openvpn/kodachi-vpn.ovpn > /dev/null 2>&1
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "Kodachi VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="kodachi-vpn.ovpn";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";					
				echo "$OS_name VPN Process Done";				
				
				sudo rm -f /etc/openvpn/kodachi-vpn.ovpn;
				sudo rm -f /etc/openvpn/auth;					
			else
				notify-send -i $notifyIcon "Failed to download $OS_name VPN";
			fi
		fi # end kodachi vpn
		
		# Kodachi-Anonymous VPN starts here
		if [[ "$vpntype" == Kodachi-Anonymous ]]
		then
			reset_VPN_IP;
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				echo "#### Will kill vpn now before starting it ####";
				sudo killall -SIGINT openvpn;			    
			fi	
					 
		     
			getID;
			sudo echo -n "kodachi|" > /etc/openvpn/auth
			sudo echo $e | cut -d ' ' -f 1 >> /etc/openvpn/auth;	
			sudo echo "cf90b117a31e7c2bb53cac3186b867b0" >> /etc/openvpn/auth;	
			kodachinodes=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachinodesanonymouse'|xargs);
			if(sudo timeout 60 wget "$kodachinodes" -q)
			then
				sudo rm -f /etc/openvpn/kodachi-vpn-tor.ovpn
				7z x *vpn*.zip -pa30@06e61-79-34-88-A4-C3@ -o/etc/openvpn/ -y &> /dev/null;
				rm -f *kodachi-vpn*

				#Get proto  port ip
				theOvfile="/etc/openvpn/kodachi-vpn-tor.ovpn";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";  
				
				sudo openvpn --daemon --config /etc/openvpn/kodachi-vpn-tor.ovpn > /dev/null 2>&1
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "Kodachi VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="kodachi-vpn.ovpn";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";					
				echo "$OS_name VPN Process Done";				
				
				sudo rm -f /etc/openvpn/kodachi-vpn.ovpn;
				sudo rm -f /etc/openvpn/auth;					
			else
				notify-send -i $notifyIcon "Failed to download $OS_name VPN";
			fi
		fi # end Kodachi-Anonymous
		
		
		
		
		
		# Rise VPN
		if [[ "$vpntype" == *Rise* ]]
		then
			reset_VPN_IP;
			
		
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;				
				fi	
							 
			    #Get proto  port ip
				theOvfile="-";
				theVPNport="-";
				theVPNproto="-"; 
				theVPNipUsed="-";
				randomvpngatepick="-";
				
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";	
							
				SERVICE2='riseup-vpn';				
				if !(ps ax | grep -v grep | grep $SERVICE2 > /dev/null)
				then
					sudo riseup-vpn -start-vpn on &
				fi
				
				theTime=$(date +%H:%M);
				notify-send -t 30000 -i $notifyIcon "Connecting to Rise VPN" "$(echo -e " \nTime: $theTime")"; 
			    sleep 5;
								
				theVPNProfile="$randomvpngatepick";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";
				echo "Rise VPN Process Done";
							
			 			 
		fi	# end Rise vpn
		
		
		
		
		
		
		
		
		
		if [[ "$vpntype" == *Gate* ]]
		then
			reset_VPN_IP;
			# get variables from config
			source $VPN_configs_path/vpngatesetup
			if [[ $randomnvpngate==0 ]] || [[ $randomnvpngate==1 ]]   
			then
		
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;				
				fi	
							 
			
				if [[ "$randomnvpngate" == 1 ]]
				then
				
					randomvpngatepick=$(ls $VPN_gate_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for VPN Gate:$randomvpngatepick";
				else
					randomvpngatepick=$vpngateprofilenametouse;
					echo "User has selected profile for VPN Gate:$randomvpngatepick";
					if [[ ! -f "$VPN_gate_ovpn_dir/$randomvpngatepick" ]] || [[ ! -n "$randomvpngatepick" ]];  
					then
						notify-send -i $notifyIcon "VPN Gate profile $randomvpngatepick is missing correct the vpngatesetup file:" \ "$VPN_configs_path/vpngatesetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_gate_ovpn_dir/$randomvpngatepick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";	
				
				
				sudo openvpn --daemon --config $VPN_gate_ovpn_dir/$randomvpngatepick > /dev/null 2>&1;
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "VPN Gate will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="$randomvpngatepick";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";
				echo "VPNGATE VPN Process Done";
				
				
				
			else
				notify-send -i $notifyIcon "VPN Gate needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				timeout 120 gedit $VPN_configs_path/vpngatesetup;			   	
			
			fi
			 
		fi	# end vpngate
		
		
		
		
		
		if [[ "$vpntype" == *Kern* ]]
		then
			reset_VPN_IP;
			# get variables from config
			source $VPN_configs_path/kernvpnsetup
			if [[ $randomkernvpn==0 ]] || [[ $randomkernvpn==1 ]]   
			then
		
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;						
				fi	
							 
			
				if [[ "$randomkernvpn" == 1 ]]
				then
				
					randomkernvpnpick=$(ls $VPN_kern_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for Kern VPN:$randomkernvpnpick";
				else
					randomkernvpnpick=$kernvpnfilenameuse;
					echo "User has selected profile for Kern VPN:$randomkernvpnpick";
					if [[ ! -f "$VPN_kern_ovpn_dir/$randomkernvpnpick" ]] || [[ ! -n "$randomkernvpnpick" ]];  
					then
						notify-send -i $notifyIcon "Kern VPN profile $randomkernvpnpick is missing correct the kernvpnsetup file:" \ "$VPN_configs_path/kernvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_kern_ovpn_dir/$randomkernvpnpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";	 				
				
				
				sudo openvpn --daemon --config $VPN_kern_ovpn_dir/$randomkernvpnpick > /dev/null 2>&1;
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "Kern VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="$randomkernvpnpick";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";
				echo "Kern VPN Process Done";				 
				
				
			else
				notify-send -i $notifyIcon "Kern VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				timeout 120 gedit $VPN_configs_path/kernvpnsetup;			   	
			
			fi
			 
		fi	# end Kernvpn	
		
		
			 
		
		 
	
		if [[ "$vpntype" == *Nord* ]]
		then
			reset_VPN_IP;
			# get variables from config
			source $VPN_configs_path/nordvpnsetup
			
			if [[ -n "$NordVPNusername" ]] ||  [[  -n "$NordVPNpassword" ]]
			then
			 
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;						
				fi	
						 
			
				if [[ "$randomnordvpn" == 1 ]]
				then
				
					randomNordpick=$(ls $VPN_nord_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for Nord VPN:$randomNordpick";
				else
					randomNordpick=$nordprofilenametouse;
					echo "User has selected profile for Nord VPN:$randomNordpick";
					if [[ ! -f "$VPN_nord_ovpn_dir/$randomNordpick" ]] || [[ ! -n "$randomNordpick" ]];  
					then
						notify-send -i $notifyIcon "Nord VPN profile $randomNordpick is missing correct the nordvpnsetup file:" \ "$VPN_configs_path/nordvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_nord_ovpn_dir/$randomNordpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";	
				
				
				NEWLINE=$'\n'
				echo "$NordVPNusername$NEWLINE$NordVPNpassword" > $VPN_configs_path/nordvpnauth.txt
				sudo openvpn --daemon --config $VPN_nord_ovpn_dir/$randomNordpick > /dev/null 2>&1;
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "Nord VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="$randomNordpick";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";
				echo "NORDVPN Process Done";
			    rm -f $VPN_configs_path/nordvpnauth.txt;
				    
			
			else
				notify-send -i $notifyIcon "Nord VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				timeout 120 gedit $VPN_configs_path/nordvpnsetup;			   	
			
			fi
			 
		fi	# end nordvpn	 	
		
		
		
		
		if [[ "$vpntype" == *Hideme* ]]
		then
			reset_VPN_IP;
			# get variables from config
			source $VPN_configs_path/hidemevpnsetup
			
			if [[ -n "$HidemeVPNusername" ]] ||  [[  -n "$HidemeVPNpassword" ]]
			then
			 
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;						
				fi	
						 
			
				if [[ "$randomhidemevpn" == 1 ]]
				then
				
					randomhidemepick=$(ls $VPN_hideme_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for Hideme VPN:$randomhidemepick";
				else
					randomhidemepick=$hidemeprofilenametouse;
					echo "User has selected profile for Hideme VPN:$randomhidemepick";
					if [[ ! -f "$VPN_hideme_ovpn_dir/$randomhidemepick" ]] || [[ ! -n "$randomhidemepick" ]];  
					then
						notify-send -i $notifyIcon "Hideme VPN profile $randomhidemepick is missing correct the hidemevpnsetup file:" \ "$VPN_configs_path/hidemevpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_hideme_ovpn_dir/$randomhidemepick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";				
				
				
				NEWLINE=$'\n';
				echo "$HidemeVPNusername$NEWLINE$HidemeVPNpassword" > $VPN_configs_path/hidemevpnauth.txt
				sudo openvpn --daemon --config $VPN_hideme_ovpn_dir/$randomhidemepick > /dev/null 2>&1;
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "Hideme VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="$randomhidemepick";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";
				echo "HideMe Process Done";
			    rm -f $VPN_configs_path/hidemevpnauth.txt;
			    
				
			else
				notify-send -i $notifyIcon "Hideme VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				timeout 120 gedit $VPN_configs_path/hidemevpnsetup;			   	
			
			fi
			 
		fi	# end hidemevpn	 	
		
		
		
		if [[ "$vpntype" == *Proton* ]]
		then
			reset_VPN_IP;
			# get variables from config
			source $VPN_configs_path/protonvpnsetup
			
			if [[ -n "$ProtonVPNusername" ]] ||  [[  -n "$ProtonVPNpassword" ]]
			then
			 
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;					
				fi	
						 
			
				if [[ "$randomprotonvpn" == 1 ]]
				then
				
					if [[ "$protonfree" == 1 ]]
					then
						randomprotonpick=$(ls $VPN_proton_ovpn_dir |grep free |sort -R|shuf -n 1);
						echo "Pickced up random free profile for Proton VPN:$randomprotonpick";
					else
						randomprotonpick=$(ls $VPN_proton_ovpn_dir |grep -v free |sort -R|shuf -n 1);
						echo "Pickced up random profile for Proton VPN:$randomprotonpick";
					fi
				else
					randomprotonpick=$protonprofilenametouse;
					echo "User has selected profile for Proton VPN:$randomprotonpick";
					if [[ ! -f "$VPN_proton_ovpn_dir/$randomprotonpick" ]] || [[ ! -n "$randomprotonpick" ]];  
					then
						notify-send -i $notifyIcon "Proton VPN profile $randomprotonpick is missing correct the protonvpnsetup file:" \ "$VPN_configs_path/protonvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_proton_ovpn_dir/$randomprotonpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|head -n 1|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";			
				
				
				NEWLINE=$'\n';
				echo "$ProtonVPNusername$NEWLINE$ProtonVPNpassword" > $VPN_configs_path/protonvpnauth.txt
				sudo openvpn --daemon --config $VPN_proton_ovpn_dir/$randomprotonpick > /dev/null 2>&1;
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "Proton VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="$randomprotonpick";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";
				echo "Proton Process Done";
			    rm -f $VPN_configs_path/protonvpnauth.txt;
				   
			
			else
				notify-send -i $notifyIcon "Proton VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				timeout 120 gedit $VPN_configs_path/protonvpnsetup;			   	
			
			fi
			 
		fi	# end protonvpn	 
		
		
		
		
		
		if [[ "$vpntype" == *Mullvad* ]]
		then
			reset_VPN_IP;
			# get variables from config
			source $VPN_configs_path/mullvadvpnsetup
			
			if [[ -n "$MullvadVPNusername" ]] ||  [[  -n "$MullvadVPNpassword" ]]
			then
			 
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;		
				
				fi	
						 
			
				if [[ "$randommullvadvpn" == 1 ]]
				then
				
					randommullvadpick=$(ls $VPN_mullvad_ovpn_dir |sort -R|shuf -n 1);
					echo "Pickced up random profile for Mullvad VPN:$randommullvadpick";
				else
					randommullvadpick=$mullvadprofilenametouse;
					echo "User has selected profile for Mullvad VPN:$randommullvadpick";
					if [[ ! -f "$VPN_mullvad_ovpn_dir/$randommullvadpick" ]] || [[ ! -n "$randommullvadpick" ]];  
					then
						notify-send -i $notifyIcon "Mullvad VPN profile $randommullvadpick is missing correct the mullvadvpnsetup file:" \ "$VPN_configs_path/mullvadvpnsetup";
					fi
				fi
				 
			
				#Get proto  port ip
				theOvfile="$VPN_mullvad_ovpn_dir/$randommullvadpick";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";		
				
			    
				NEWLINE=$'\n';
				echo "$MullvadVPNusername$NEWLINE$MullvadVPNpassword" > $VPN_configs_path/mullvadvpnauth.txt
				sudo openvpn --daemon --config $VPN_mullvad_ovpn_dir/$randommullvadpick > /dev/null 2>&1;
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "Mullvad VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="$randommullvadpick";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";
				echo "Mullvad Process Done";
			    rm -f $VPN_configs_path/mullvadvpnauth.txt;
				
				
			else
				notify-send -i $notifyIcon "Mullvad VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				timeout 120 gedit $VPN_configs_path/mullvadvpnsetup;			   	
			
			fi
			 
		fi	# end mullvadvpn	 		
		
		
		
		
		if [[ "$vpntype" == *Own* ]]
		then
			reset_VPN_IP;
			source $VPN_configs_path/myownvpnsetup			
			if grep "dev tun" $VPN_configs_path/myownvpn.ovpn > /dev/null		 
			then
		
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "#### Will kill vpn now before starting it ####";
					sudo killall -SIGINT openvpn;	
					
				fi	
						 
			
 
			
				#Get proto  port ip
				theOvfile="$VPN_configs_path/myownvpn.ovpn";
				theVPNport=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $3}'|tail -n 1);
				theVPNproto=$(cat $theOvfile|grep "^[^#;]"|grep 'proto'|awk  '{print $2}'|tail -n 1);		 
				theVPNipUsed=$(cat $theOvfile|grep "^[^#;]"|grep 'remote '|awk  '{print $2}'|tail -n 1);
				# Get the country from the ip
				getCountry "$theVPNipUsed" "VPNStartCountryResolve";	
				
			
				if [[ "$need_user_password" == 1 ]]
				then
					NEWLINE=$'\n';
					echo "$ownvpnusername$NEWLINE$ownvpnpassword" > $VPN_configs_path/myownvpnauth.txt ;
				fi
				sudo openvpn --daemon --config $VPN_configs_path/myownvpn.ovpn > /dev/null 2>&1;
				theTime=$(date +%H:%M);
				thePingS=$(fping -B 1.0 -t 1000 -i 1 -r 0 -e -c 1 -q $theVPNipUsed 2>&1 | awk -F'/' '{print $8}');
				notify-send -t 30000 -i $notifyIcon "Own VPN will connect to:" "$(echo -e "IP: $theVPNipUsed\nCountry: $theCountry\nPort: $theVPNport\nProtocol: $theVPNproto\nPing: $thePingS ms\nTime: $theTime")"; 
			
				
				theVPNport=$(echo $theVPNport | tr -d '\r');
				theVPNproto=$(echo $theVPNproto | tr -d '\r');	
				theVPNProfile="myownvpn.ovpn";
				writeToJason "$theVPNport" "VPNport";	
				writeToJason "$theVPNproto" "VPNprotocol";	
				writeToJason "$theVPNProfile" "VPNprofile";	
				writeToJason "$theVPNipUsed" "VPNprofileip";
				echo "Own VPN Process Done";
			    rm -f $VPN_configs_path/myownvpnauth.txt;
				
			else
				notify-send -i $notifyIcon "Own VPN needs to be setup first";
				sleep 2;
				bash $Mykodachi_path/beeper > /dev/null 2>&1;
				timeout 120 gedit $VPN_configs_path/myownvpn.ovpn;	
				timeout 120 gedit $VPN_configs_path/myownvpnsetup;			   	
			
			fi
			 
		fi	# end Ownvpn 	
		
		# Avoid tor starting before VPN
	    run_tor_if_vpn_is_off=$(cat $Jason_file_name | jq -r .TORonifVPNisoff);
		if [[ "$run_tor_if_vpn_is_off" == *No* ]]
		then
			sleep 25;
		fi	
		
	
	else
		echo "No Net we can't start vpns";
	fi
}


function get_isp_ip()
{
	toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
	netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
	if [[ $netStatustxt == *Online* ]] && [[ "$toriffy_Status" == *No* ]]
	then
		SERVICE='openvpn';
		if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)		 
		then
			if [ ! -n $randomdomain ]
			then
				echo " Random domain was empty so we set digi77 domain";
				
				randomdomain=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachiipcheck'|xargs);
			fi
			ISP_IP_json=$(cat $Jason_file_name | jq -r .OriginalISPIPAddress);
			if [[ $ISP_IP_json == '-' ]]  
			then
				echo "Found a dash reset isp IP";
				reset_ISP_IP;
			fi 
			
			print_good "Random Domain from ip domains is $randomdomain";
					
			ISP_IP=$(sudo curl -s -m 30 $randomdomain )	
			# Remove empty space
			ISP_IP=$(echo $ISP_IP|sed 's/ //g'|xargs);
			ISP_IP=$(echo $ISP_IP|grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
			
						
			
			    	
			if [[ -n $ISP_IP ]] && [[ $permenet_ISP_IP != $ISP_IP ]] && [[ "$ISP_IP" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]
			then				  
				writeToJason "$ISP_IP" "OriginalISPIPAddress";				
				getCountry "$ISP_IP" "ISPCountryResolve"; 					
				permenet_ISP_IP=$ISP_IP;				
				writeToJason "$ISP_Country" "OriginalISPCountry";	
			else
				print_good "Country and IP change for ISP_Country skipped already set before";
			fi
		
		
					
		fi	
	fi

	
	
}



function get_vpn_ip()
{
	
	toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
	netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
	if [[ $netStatustxt == *Online* ]] && [[ "$toriffy_Status" == *No* ]]
	then
		SERVICE='openvpn';
		if (ps ax | grep -v grep | grep $SERVICE > /dev/null) 	 
		then
			if [ ! -n $randomdomain ]
			then
				echo " Random domain was empty so we set digi77 domain";
				randomdomain=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachiipcheck'|xargs);
			fi
			
			VPN_IP_json=$(cat $Jason_file_name | jq -r .VPNIP);
			if [[ $VPN_IP_json == '-' ]]  
			then
				echo "Found a dash reset VPN ip ";
				reset_VPN_IP;
			fi 
			
			
			print_good "Random Domain from ip domains is $randomdomain";
					
			VPN_IP=$(sudo curl -s -m 30 $randomdomain )	
			# Remove empty space
			VPN_IP=$(echo $VPN_IP|sed 's/ //g'|xargs);
			VPN_IP=$(echo $VPN_IP|grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
			
			if [[ -n $VPN_IP ]] && [[ $permenet_VPN_IP != $VPN_IP ]] && [[ "$VPN_IP" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]
			then
				writeToJason "$VPN_IP" "VPNIP";	
				securityStatus="secure";	
				writeToJason "$securityStatus" "SecurityStatus";		
				getCountry "$VPN_IP" "VPNCountryResolve"; 					
				permenet_VPN_IP=$VPN_IP;				
				writeToJason "$VPN_Country" "VPNCountry";	
			else
				print_good "Country for VPN_Country skipped already set before";	
			fi				
				
				
		else				
			securityStatus="notsecure";	
			writeToJason "$securityStatus" "SecurityStatus";
			unset VPN_IP;
			unset VPN_Country;
			writeToJason "$tempjqdash" "VPNIP";
			writeToJason "$tempjqdash" "VPNCountry";					
		fi
		    
		
	fi	
	

	
	
	
}



function get_tor_ip()
{
	
	netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
	if [[ $netStatustxt == *Online* ]]
	then
		SERVICE='tor-service';
		if (ps ax | grep -v grep | grep $SERVICE > /dev/null)		 
		then
			if [ ! -n $randomdomain ]
			then
				echo " Random domain was empty so we set digi77 domain";
				randomdomain=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachiipcheck'|xargs);
			fi
			
			toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
			if [[ "$toriffy_Status" == *no* ]]
			then	
			
				TOR_IP_json=$(cat $Jason_file_name | jq -r .TORIP);
				if [[ $TOR_IP_json == '-' ]]  
				then
					echo "Found a dash reset TOR IP ";
					reset_TOR_IP;
				fi 
			fi
			
			
			print_good "Random Domain from ip domains is $randomdomain";
			TOR_IP=$(sudo curl --proxy socks5h://localhost:9050 -s -m 20 $randomdomain )		 		
			# Remove empty space
			TOR_IP=$(echo $TOR_IP|sed 's/ //g'|xargs);
			TOR_IP=$(echo $TOR_IP|grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
			
			
			if [[ -n $TOR_IP ]] && [[ $permenet_TOR_IP != $TOR_IP ]] && [[ "$TOR_IP" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]
			then
				writeToJason "$TOR_IP" "TORIP";		
				getCountry "$TOR_IP" "TORCountryReolve";											
				permenet_TOR_IP=$TOR_IP;			
				writeToJason "$TOR_Country" "TORCountry";
			else
				print_good "Country for TOR_Country skipped already set before";		
			fi				
			
					
		else
			unset TOR_IP;
			unset TOR_Country;
			writeToJason "$tempjqdash" "TORIP";
			writeToJason "$tempjqdash" "TORCountry";
		
		fi	
	
	fi
}


function get_torrify_ip()
{
		
	netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
	if [[ $netStatustxt == *Online* ]]
	then
		SERVICE='tor-service';
		if (ps ax | grep -v grep | grep $SERVICE > /dev/null)		 
		then
			if [ ! -n $randomdomain ]
			then
				echo " Random domain was empty so we set digi77 domain";
				randomdomain=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachiipcheck'|xargs);
			fi
			
			toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
			if [[ "$toriffy_Status" == *Yes* ]]
			then	
				
				TORRIFY_IP_json=$(cat $Jason_file_name | jq -r .TORRIFYIP);
				if [[ $TORRIFY_IP_json == '-' ]]  
				then
					echo "Found a dash reset TORRIFY IP ";
					reset_TOR_IP;
				fi 
				
				
				print_good "Random Domain from ip domains is $randomdomain";
				TORRIFY_IP=$(sudo curl -s -m 30 $randomdomain )			 		
				# Remove empty space
				TORRIFY_IP=$(echo $TORRIFY_IP|sed 's/ //g'|xargs);
				TORRIFY_IP=$(echo $TORRIFY_IP|grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}');
				
				
				if [[ -n $TORRIFY_IP ]] && [[ $permenet_TORRIFY_IP != $TORRIFY_IP ]] && [[ "$TORRIFY_IP" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]
				then
					writeToJason "$TORRIFY_IP" "TORRIFYIP";	
					getCountry "$TORRIFY_IP" "TORIFFYCountryReolve"; 										
					permenet_TORRIFY_IP=$TORRIFY_IP;			
					writeToJason "$TORRIFY_Country" "TORRIFYCountry";
				else
					print_good "Country for TORRIFY_Country skipped already set before";		
				fi				
								
			fi	
		else
		
			unset TORRIFY_IP;
			unset TORRIFY_Country;
			writeToJason "$tempjqdash" "TORRIFYIP";
			writeToJason "$tempjqdash" "TORRIFYCountry";
		fi

	fi	
	
	
}

function fetchallips()
{
	get_isp_ip;	
	get_vpn_ip;	
	get_tor_ip;	
	get_torrify_ip;
			
}





function waitForTor2beready()
{
	
	echo "waitForTor2beready function start";
	tornullipcounter=0;
	SERVICE='tor-service';
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)	
	then		
		TorCon=0;
		writeToJason "$TorCon" "$jsonvarName";
		while [[ $TorCon -eq 0 ]]; do
			tornullipcounter=$((tornullipcounter+1));
			echo "*************************  waiting for Tor to be ready  **********************";
			echo -e "\n"
			#while [[ ! `timeout 50 torsocks curl --connect-timeout 15 --retry 5 $kodachiipcheck 2>/dev/null` ]]; do sleep 1; done
			
			local hostport="localhost:9050" 
			local url=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].torstatuschecksite'|xargs);
			if [[ ! -n "$url" ]]
			then
				url="https://check.torproject.org/";
				print_error "Failed to get TOR site from json setting value to: $url";
			fi
				
			
			torsearchkeyword=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].torsearchkeyword'|xargs);
			if [[ ! -n "$torsearchkeyword" ]]
			then
				torsearchkeyword="Congratulations";
				print_error "Failed to get TOR search keyword from json setting value to: $torsearchkeyword";
			fi
			
			
			if curl -s -m 15 --socks5 "$hostport" --socks5-hostname "$hostport" -L "$url" | cat | tac | grep -q "$torsearchkeyword";  
			then
				TorCon=1;
				tornullipcounter=0;	
				writeToJason "$TorCon" "$jsonvarName";	
				print_good "Torrify is on good site used: $url serachkeyword is:$torsearchkeyword";
			else
				TorCon=0;
				writeToJason "$TorCon" "$jsonvarName";	
				print_error "Torrify is off bad TOR will restart site used: $url serachkeyword is:$torsearchkeyword";
					
				rand=$[$RANDOM % ${#arr[@]}]
				COuntryCode=${arr[$rand]};
			
				if [[ $tornullipcounter -le 5 ]]
				then
					# for some how some tor nodes are banned
					sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={$COuntryCode};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
					print_error "Try to switch TOR to: $COuntryCode tornullipcounter is: $tornullipcounter";	
				fi
												
				if [[ $tornullipcounter > 5 ]]
				then
					# for some how some tor nodes are banned
					sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={$COuntryCode};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
					print_error "Try to switch TOR to: $COuntryCode tornullipcounter is: $tornullipcounter";	
					sleep 1							
					sudo /etc/init.d/tor restart;
					print_error "Giving up on country atttempts restarting TOR";
					sleep 1;
				fi
				echo "Tor while loop result: $TorCon";
				sleep 5; 
			fi
			
		done
	fi
}





 

# Sorry but we don't want ur eyes on our traffic {us},{uk},{ca},{nz},{au},{dk},{fr},{nl},{no},{de},{be},{es},{it},{se}
function ex14Countries()
{
#Ref
#SETCONF ExitNodes={ac},{af},{ax},{al},{dz},{ad},{ao},{ai},{aq},{ag},{ar},{am},{aw},{at},{az},{bs},{bh},{bd},{bb},{by},{bz},{bj},{bm},{bt},{bo},{ba},{bw},{bv},{br},{io},{vg},{bn},{bg},{bf},{bi},{kh},{cm},{cv},{ky},{cf},{td},{cl},{cn},{cx},{cc},{co},{km},{cg},{cd},{ck},{cr},{ci},{hr},{cu},{cy},{cz},{dj},{dm},{do},{tp},{ec},{eg},{sv},{gq},{ee},{et},{fk},{fo},{fj},{fi},{fx},{gf},{pf},{tf},{ga},{gm},{ge},{gh},{gi},{gr},{gl},{gd},{gp},{gu},{gt},{gn},{gw},{gy},{ht},{hm},{hn},{hk},{hu},{is},{in},{id},{ir},{iq},{ie},{im},{il},{it},{jm},{jp},{jo},{kz},{ke},{ki},{kp},{kr},{kw},{kg},{la},{lv},{lb},{ls},{lr},{ly},{li},{lt},{lu},{mo},{mk},{mg},{mw},{my},{mv},{ml},{mt},{mh},{mq},{mr},{mu},{yt},{mx},{fm},{md},{mc},{mn},{me},{ms},{ma},{mz},{mm},{na},{nr},{np},{an},{nc},{ni},{ne},{ng},{nu},{nf},{mp},{om},{pk},{pw},{ps},{pa},{pg},{py},{pe},{ph},{pn},{pl},{pt},{pr},{qa},{re},{ro},{ru},{rw},{ws},{sm},{st},{sa},{uk},{sn},{rs},{sc},{sl},{sg},{sk},{si},{sb},{so},{as},{za},{gs},{su},{lk},{sh},{kn},{lc},{pm},{vc},{sd},{sr},{sj},{sz},{ch},{sy},{tw},{tj},{tz},{th},{tg},{tk},{to},{tt},{tn},{tr},{tm},{tc},{tv},{ug},{ua},{ae},{gb},{um},{uy},{uz},{vu},{va},{ve},{vn},{vi},{wf},{eh},{ye},{zm},{zw}

	# tor tester 1
	CONTROLPORT=9060;
cat <<'EOF' | nc localhost $CONTROLPORT
authenticate "Auo2@s3ks@Wdq"
SETCONF ExcludeNodes={us},{uk},{ca},{nz},{au},{dk},{fr},{nl},{no},{de},{be},{es},{it},{se}
SETCONF ExcludeExitNodes={us},{uk},{ca},{nz},{au},{dk},{fr},{nl},{no},{de},{be},{es},{it},{se}
SETCONF StrictNodes=1
signal newnym
quit
EOF

}


 


function checkRemoteUpdates()
{
		
	R_status_file="$Mykodachi_path/status_R_updates";
	# get the content first
	cd  $Mykodachi_path/
	sudo rm -f $R_status_file
	kodachiremoteupdatesurldir=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachiremoteupdatesurldir'|xargs);
	curl -s -m 30 $kodachiremoteupdatesurldir|cut -d , -f 2 > $R_status_file
	sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/status_R_updates;
	end_of_file=0;
	
	while [[ $end_of_file == 0 ]]
	do
		  read -r line
		  # the last exit status is the 
		  # flag of the end of file
		  end_of_file=$?;
		  x=$line;
		  if [[ $x == *$kodachi_version* ]]; then
				#echo $x;	   
			    toUpdate=$(echo $x | awk '{ gsub(/:+/, " " ); print $3; }');
			    #echo $toUpdate
			    echo "checkRemoteUpdates: $toUpdate";
			   
				if [[ "$toUpdate" == 1 ]];then
					echo $kodachi_version "has an update vale is: " $toUpdate "from the string: " $x;
					rm -f "$kodachi_version.zip"
					rm -f -r $kodachi_version
					kodachiremoteupdatesurl=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachiremoteupdatesurl'|xargs);
					wget "$kodachiremoteupdatesurl/$kodachi_version" -q 
					mv $kodachi_version $kodachi_version.zip
					unzip -P 9q40@06e61-7iZ-59-8mt-A4-E6@ $kodachi_version.zip
					rm -f $kodachi_version.zip
					#sudo chown $LOGED_USER.$LOGED_USER $kodachi_version -R
					cd $kodachi_version
					sudo chmod +x rc
					#windows cause space error this is how to solve it
					sed -i 's/\r$//' rc
					sudo bash rc
					cd ..
					rm -f -r $kodachi_version
				else
					echo $kodachi_version "has no update value is: " $toUpdate "from the string: " $x;
				fi		  
		  fi
	  
	done < "$R_status_file"
	 
	rm -f $R_status_file;
}

function copyAptsubs()
{
	
	# Additinal sources
	pFile="/etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list";
	pFilex2="/etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save";
	if !(grep -q libreoffice "$pFile") || !(grep -q libreoffice "$pFilex2") ; then
		  print_error "Someone touched my additional apt files I will restore them";
		  print_good " Removing all files";
		  sudo rm -f /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save
		  sudo rm -f /etc/apt/sources.list.d/gambas-team-ubuntu-gambas3-bionic.list
		  #sudo rm -f /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list
		  #sudo rm -f /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save
		  #sudo rm -f /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list
		  #sudo rm -f /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save
		  #sudo rm -f /etc/apt/sources.list.d/signal-xenial.list
		  #sudo rm -f /etc/apt/sources.list.d/signal-xenial.list.save				  
		  #sudo rm -f /etc/apt/sources.list.d/syncthing.list
		  #sudo rm -f /etc/apt/sources.list.d/syncthing.list.save
		  #sudo rm -f /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list
		  #sudo rm -f /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list.save
		  #sudo rm -f /etc/apt/sources.list.d/zelcash.list
		  #sudo rm -f /etc/apt/sources.list.d/zelcash.list.save
		  sudo rm -f /etc/apt/sources.list.d/riot-im.list
		  sudo rm -f /etc/apt/sources.list.d/riot-im.list.save
		  sudo rm -f /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list
		  sudo rm -f /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list.save
		  #sudo rm -f /etc/apt/sources.list.d/i2p-maintainers-ubuntu-i2p-bionic.list
		  #sudo rm -f /etc/apt/sources.list.d/i2p-maintainers-ubuntu-i2p-bionic.list.save
		  
		  
		  
		  print_good "Coping all files";
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/libreoffice-ubuntu-ppa-bionic.list /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/gambas-team-ubuntu-gambas3-bionic.list /etc/apt/sources.list.d/gambas-team-ubuntu-gambas3-bionic.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/gambas-team-ubuntu-gambas3-bionic.list.save /etc/apt/sources.list.d/gambas-team-ubuntu-gambas3-bionic.list.save
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/micahflee-ubuntu-ppa-bionic.list /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list 
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save 
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list 
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save 
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/signal-xenial.list /etc/apt/sources.list.d/signal-xenial.list 
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/signal-xenial.list.save /etc/apt/sources.list.d/signal-xenial.list.save			  
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/syncthing.list /etc/apt/sources.list.d/syncthing.list
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/syncthing.list.save /etc/apt/sources.list.d/syncthing.list.save 
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list.save /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list.save
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/zelcash.list /etc/apt/sources.list.d/zelcash.list
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/zelcash.list.save /etc/apt/sources.list.d/zelcash.list.save
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/leap.list /etc/apt/sources.list.d/syncthing.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/leap.list.save /etc/apt/sources.list.d/syncthing.list.save 
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/leap.list /etc/apt/sources.list.d/leap.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/leap.list.save /etc/apt/sources.list.d/leap.list.save
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/riot-im.list /etc/apt/sources.list.d/riot-im.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/riot-im.list.save /etc/apt/sources.list.d/riot-im.list.save
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list
		  sudo cp $Mykodachi_path/apt-live/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list.save /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list.save
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/i2p-maintainers-ubuntu-i2p-bionic.list /etc/apt/sources.list.d/i2p-maintainers-ubuntu-i2p-bionic.list
		  #sudo cp $Mykodachi_path/apt-live/sources.list.d/i2p-maintainers-ubuntu-i2p-bionic.list.save /etc/apt/sources.list.d/i2p-maintainers-ubuntu-i2p-bionic.list.save
		  
		  
		  print_good "Chown root all copied files";
		  sudo chown root.root /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list.save
		  sudo chown root.root /etc/apt/sources.list.d/gambas-team-ubuntu-gambas3-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/gambas-team-ubuntu-gambas3-bionic.list.save
		  #sudo chown root.root /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list
		  #sudo chown root.root /etc/apt/sources.list.d/micahflee-ubuntu-ppa-bionic.list.save
		  #sudo chown root.root /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list
		  #sudo chown root.root /etc/apt/sources.list.d/shevchuk-ubuntu-dnscrypt-proxy-bionic.list.save
		  #sudo chown root.root /etc/apt/sources.list.d/signal-xenial.list
		  #sudo chown root.root /etc/apt/sources.list.d/signal-xenial.list.save				  
		  #sudo chown root.root /etc/apt/sources.list.d/syncthing.list
		  #sudo chown root.root /etc/apt/sources.list.d/syncthing.list.save
		  #sudo chown root.root /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list
		  #sudo chown root.root /etc/apt/sources.list.d/phoerious-ubuntu-keepassxc-bionic.list.save
		  #sudo chown root.root /etc/apt/sources.list.d/zelcash.list
		  #sudo chown root.root /etc/apt/sources.list.d/zelcash.list.save
		  sudo chown root.root /etc/apt/sources.list.d/syncthing.list
		  sudo chown root.root /etc/apt/sources.list.d/syncthing.list.save 
		  sudo chown root.root /etc/apt/sources.list.d/leap.list
		  sudo chown root.root /etc/apt/sources.list.d/leap.list.save
		  sudo chown root.root /etc/apt/sources.list.d/riot-im.list
		  sudo chown root.root /etc/apt/sources.list.d/riot-im.list.save
		  sudo chown root.root /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list
		  sudo chown root.root /etc/apt/sources.list.d/oguzhaninan-ubuntu-stacer-bionic.list.save
		  #sudo chown root.root /etc/apt/sources.list.d/i2p-maintainers-ubuntu-i2p-bionic.list
		  #sudo chown root.root /etc/apt/sources.list.d/i2p-maintainers-ubuntu-i2p-bionic.list.save
		 
		  
		  
	fi
	
}


function copyAptmains()
{
	#Main sources
	pFile="/etc/apt/sources.list";
	if (grep -q 'deb cdrom:\[Linux' "$pFile"); then
		print_error "Someone touched my main apt files I will restore them";
		print_good " Removing all files";
		sudo rm -f /etc/apt/sources.list
		sudo rm -f /etc/apt/sources.list.save 	
		print_good "Coping all files";	
		sudo cp $Mykodachi_path/apt-live/sources.list /etc/apt/sources.list
		sudo cp $Mykodachi_path/apt-live/sources.list.save /etc/apt/sources.list.save 	
		print_good "Chown root all copied files";
		sudo chown root.root /etc/apt/sources.list
		sudo chown root.root /etc/apt/sources.list.save 	
		print_good "deb [trusted=yes] file:/cdrom/dists/ ./  # ISO repo - BB" |sudo tee -a /etc/apt/sources.list
	fi
	
}



function getRemoteKodachijson()
{
	
	echo "Time to get json from  web";
	if (sudo curl -s -m 20 -X GET "$Remote_Jason_name" -H  "accept: application/json" > temp.json)
	then
	    mv -f temp.json $Jason_web_file_name;
	    if ( cat $Jason_web_file_name|grep Netcheckdomain > /dev/null 2>&1 ) 
		then 			
			rm -f "$Jason_web_file_name.backup";
			cp -f $Jason_web_file_name "$Jason_web_file_name.backup";
			print_good "$Remote_Jason_name retrieved successfully"
		else
			print_error "Failed to get kodachi web json in correct format from: $Remote_Jason_name getting backup file";
			cp -f "$Jason_web_file_name.backup" $Jason_web_file_name;
		fi	
	else	    
		print_error "Failed to get kodachi web json from: $Remote_Jason_name getting backup file";
		cp -f "$Jason_web_file_name.backup" $Jason_web_file_name;
	fi	
	sudo chown $LOGED_USER.$LOGED_USER $Jason_web_file_name; 
	sudo chown $LOGED_USER.$LOGED_USER "$Jason_web_file_name.backup"; 
	
	
}











function getVersion()
{
	KO_Version=$(cat $Jason_web_file_name | jq -r .version);
	  
	if [ -n "$KO_Version" ]  
	then
		
			
		if [[ "$KO_Version" != $Kodachi_version ]]
		then			 
			writeToJason "!:!" "KodachiISOVersionAlert";     			
								
		else
			writeToJason ":!" "KodachiISOVersionAlert"; 			
		fi	
	fi 
	
	 
}


 	


 		


function resetalljson()
{
  # Do not dash them to avoid issues
  #writeToJason "$tempjqdash" "InternetStatus";
  #writeToJason "$tempjqdash" "swapstatus";
  #writeToJason "$tempjqdash" "netintused";
  #writeToJason "$tempjqdash" "InternetStatusbydomainonly";
  writeToJason "$tempjqdash" "OriginalISPIPAddress";
  writeToJason "$tempjqdash" "OriginalISPCountry";
  writeToJason "$tempjqdash" "VPNIP";
  writeToJason "$tempjqdash" "VPNCountry";
  writeToJason "$tempjqdash" "SecurityStatus";
  writeToJason "$tempjqdash" "TORIP";
  writeToJason "$tempjqdash" "TORCountry";
  writeToJason "$tempjqdash" "TORRIFYIP";
  writeToJason "$tempjqdash" "TORRIFYCountry";
  writeToJason "$tempjqdash" "memoryused";
  writeToJason "$tempjqdash" "openfiles";
  writeToJason "$tempjqdash" "boottype";
  writeToJason "$tempjqdash" "banstatus";
  writeToJason "$tempjqdash" "livemode";
  writeToJason "$tempjqdash" "kodachihwid"; 
  writeToJason "$tempjqdash" "printcapsstatus";
  writeToJason "$tempjqdash" "torblock";
  writeToJason "$tempjqdash" "osnukestatus";
  writeToJason "$tempjqdash" "hddencryptstatus";
  writeToJason "$tempjqdash" "tordns";
  writeToJason "$tempjqdash" "swapcryptstatus";  
  writeToJason "$tempjqdash" "totalswap";
  writeToJason "$tempjqdash" "securityscore";
  writeToJason "$tempjqdash" "securitymodel";
  writeToJason "$tempjqdash" "firewallstatus";
  writeToJason "$tempjqdash" "kodachivpnbandwidth";
  writeToJason "$tempjqdash" "VPNport";
  writeToJason "$tempjqdash" "VPNprotocol";
  writeToJason "$tempjqdash" "VPNprofile";
  writeToJason ":!" "KodachiISOVersionAlert";
  
 
}





 

 



function mainwork_NO_net_simple_tasks_repeated()
{
 
	
	# Set ipv6
	theIP6s=$(cat /proc/sys/net/ipv6/conf/all/disable_ipv6);	
	if [[ $theIP6s == 1 ]]
	then
		sudo sysctl -p;
		writeToJason "No" "ipv6status";	
		securityScore=$((securityScore+10))
	else
		writeToJason "Yes" "ipv6status";	
	
	fi	
	
	# Clean json log file
	# 104857600 = 1024 * 1024 * 100 = 100M
	filename="json.log"  
	if [ $(($(stat -c %s $filename)/1024/1024)) -ge 2 ]  ; then cat /dev/null > $filename ; fi
	sudo chown $LOGED_USER.$LOGED_USER json.log; 
	
	# Get version online
	print_good "Time to compare versions";
	getVersion;	
	
	#Get memroy used
	getMem	
	
	# Getid
	getID;
	
		
	# Set printer cups for conky
	if(sudo service cups status|grep inactive > /dev/null)
	then
		writeToJason "No" "printcapsstatus";		
	else
		writeToJason "Yes" "printcapsstatus";
	fi
	 
	# set swap file on off	
	swapstatus=$(cat $Jason_file_name | jq -r .swapstatus);	        
	if [[ "$swapstatus" == *Yes* ]]
	then
		sudo swapon -a;
	else
		sudo swapoff -a;		
	fi
	
	# Set usbguard for conky
	if(sudo service usbguard status|grep inactive > /dev/null)
	then
		writeToJason "No" "usbguardstatus";		
	else
		writeToJason "Yes" "usbguardstatus";
	fi		 

	
	# Set usbkill for conky
	SERVICE='usbkill';
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
	then	 	
		writeToJason "Yes" "usbkillstatus";
	else
		writeToJason "No" "usbkillstatus";
	fi
	
	
	
	# Set hdd encryption status
	getSDA=$(lsblk|egrep crypt|cut -d _ -f 1| sed 's/[^a-zA-Z0-9]//g');	
	if [[ -n $getSDA ]] 
	then
		writeToJason "Yes" "hddencryptstatus";
	else
		writeToJason "No" "hddencryptstatus";		
	fi
	
    # for conky ufw status			
	if (sudo ufw status|grep inactive)
	then
		writeToJason "No" "firewallstatus";
	else
		writeToJason "Yes" "firewallstatus";
	fi

	
	# Set swapcrypt on conky
	if (cat /etc/crypttab|grep cryptswap > /dev/null) 
	then
		writeToJason "Yes" "swapcryptstatus";
	else
		writeToJason "No" "swapcryptstatus";
	fi
	
	# Get total swaps
	numberOfcSwaps=$(sudo swapon -s|grep -v Filename|wc -l);
	writeToJason "$numberOfcSwaps" "totalswap";
	
	
	
	# set 14 tor countries block conky
	if [[ -f /etc/tor/torrc.custom ]]
	then
		if (cat /etc/tor/torrc.custom|grep 14eyes)
		then
			writeToJason "14 countries" "torblock";
		elif (cat /etc/tor/torrc.custom|grep 9eyes)
		then
			writeToJason "9 countries" "torblock";
		
		elif (cat /etc/tor/torrc.custom|grep 5eyes)
		then
			writeToJason "5 countries" "torblock";
		fi
				
	else
		writeToJason "0 countries" "torblock";	
	fi
	
	
	
	# Set nuked on conky		
	if [[ -f  $Mykodachi_path/osnukevars ]]
	then
		source $Mykodachi_path/osnukevars
	else
		osisnuked=0;
	fi
	
	#if (apt-mark showhold|grep cryptsetup-bin > /dev/null) 
	#if [[ "$Used_Slots" -lt 2 ]]
	if [[ $osisnuked = 1 ]]
	then
		writeToJason "Yes" "osnukestatus";	
	else
		writeToJason "No" "osnukestatus";	
	fi
	
	
	
	# Installer icon offline
	fileIcon="$Myhome_path/Desktop/Install_Kodachi_Offline.desktop";
	fileIconkbase="$Mykodachi_path/Install_Kodachi_Offline.desktop";
	#xP=$(id -u $LOGED_USER)
	if [[ $xP == *990* ]] 
	then
		echo "System not installed keep the icon:$xP";
		# Check icon file if does not exists
		
		if [[ ! -f $fileIcon ]];  
		then
			cp $fileIconkbase $fileIcon;
			sudo chmod +x $fileIcon;
			sudo chown $LOGED_USER.$LOGED_USER $fileIcon;
			rm -f $Myhome_path/Desktop/ubiquity.desktop
			
		fi
		
	else
		if [[ -f $fileIcon ]];  
		then
			echo "System installed will delete icon:$xP";
			rm -f $fileIcon;
			rm -f $Myhome_path/Desktop/ubiquity.desktop
		fi
	fi
	
	
		
	# brings trouble if libe is not updated for long time
	# Installer icon Online
	fileIcon="$Myhome_path/Desktop/Install_Kodachi_Online.desktop";
	fileIconkbase="$Mykodachi_path/Install_Kodachi_Online.desktop";
	#xP=$(id -u $LOGED_USER)
	if [[ $xP == *990* ]] 
	then
		echo "System not installed keep the icon:$xP";
		# Check icon file if does not exists
		
		#if [[ ! -f $fileIcon ]];  
		#then
			#cp $fileIconkbase $fileIcon;
			#sudo chmod +x $fileIcon;
			#sudo chown $LOGED_USER.$LOGED_USER $fileIcon;
			#rm -f $Myhome_path/Desktop/ubiquity.desktop
			
		#fi
		
	else
		if [[ -f $fileIcon ]];  
		then
			echo "System installed will delete icon:$xP";
			rm -f $fileIcon;
			rm -f $Myhome_path/Desktop/ubiquity.desktop
		fi
	fi
	
	
	# Kodachi on Desktop
	# Installer icon offline
	fileIcon="$Myhome_path/Desktop/Kodachi_Dashboard.desktop";
	fileIconkbase="$Myhome_path/Kodachi_Dashboard.desktop";
	 
	# Check icon file if does not exists	
	if [[ ! -f $fileIcon ]];  
	then
		cp $fileIconkbase $fileIcon;
		sudo chmod +x $fileIcon;
		sudo chown $LOGED_USER.$LOGED_USER $fileIcon;		
	fi
	
	
	# Remove crap files from home
	rm -f $Mykodachi_path/wget-log*
	rm -f $Mykodachi_path/kodachi-vpn.zip.*
	rm -f $Mykodachi_path/core
	
	
	#monitor my apts so ubiquity and pinguy don't play with it
	#xP=$(id -u $LOGED_USER)
	if [[ $xP == 990 ]] 
	then
		
		copyAptsubs;
		copyAptmains;

		
	else # System installed 
		
		firstboot=$(cat $Jason_file_name | jq -r .firstboot);
		if [[ "$firstboot" == *Yes* ]]
		then
			copyAptsubs;
			copyAptmains;
		fi
	
	fi
	
	
	# Set interface type		
	netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
	if [[ $netStatustxt == *Online* ]]
	then
		x54=$(ip route get 8.8.8.8 | sed -nr 's/.*dev ([^\ ]+).*/\1/p');
	else
		x54=$(find /sys/class/net ! -type d | xargs --max-args=1 realpath  | awk -F\/ '/pci/{print $NF}'|head -n1 | sed -e 's/\s.*$//');
	fi
	writeToJason "$x54" "netintused";	
	
	
	
	#Check for open files	   	
	if [[ $check_n_files == 0 ]] || [[ $check_n_files == 60 ]]
	then
		echo "Getting number of opened files";
		num_files_opened=$(timeout 5 lsof -n | wc -l);
		writeToJason "$num_files_opened" "openfiles";
		check_n_files=0;
	fi
	check_n_files=$((check_n_files+1))
	
	
	
	# Check boot type	
	m=$(sudo efibootmgr)
	if echo "$m" | grep -q "BootCurrent"; then
		writeToJason "UEFI" "boottype";	
	else	
		writeToJason "Legacy" "boottype";
	fi	
	
	
	#Check if system installed
	#xP=$(id -u $LOGED_USER)
	if [[ $xP == 990 ]] 
	then
		writeToJason "Yes" "livemode";	
		 
	else
		writeToJason "No" "livemode";	
		 
	fi	
	
	
	
	
	# Check if font is correctly reported
	fontFromJson=$(cat $Jason_file_name | jq -r .Screenfontsize);
	fontFromConky=$(cat $Mykodachi_path/.conkyrc1|grep "size="|head -1|cut -d = -f 2|cut -d : -f 1);
	if [[ "fontFromJson" != "$fontFromConky" ]]	
	then
		writeToJason "$fontFromConky" "Screenfontsize"; 
	fi
	
	# VPN timers
	vpn_timers;
	 
	
	
}

function vpn_timers()
{
 
	#Rise-VPN
	if (ps -eo pid,command,etime|grep 'openvpn --setenv'> /dev/null)
	then		 
		vpnTimer=$(ps -eo pid,command,etime|grep -v grep|grep '/openvpn --setenv'|awk  '{print $4}'|xargs);
		writeToJason "$vpnTimer" "vpnTime";
	fi
	
	#Other-VPNS
	if (ps -eo pid,command,etime|grep 'openvpn --daemon --config'> /dev/null)
	then		 
		vpnTimer=$(ps -eo pid,command,etime|grep -v grep|grep 'openvpn --daemon --config'|awk  '{print $6}'|xargs);
		writeToJason "$vpnTimer" "vpnTime";
	fi
	
}

 

function mainwork_NO_net_scoring()
{
	#Scroring tasks	
		
	# Set login status cony
	if(grep -R $LOGED_USER /usr/share/lightdm/lightdm.conf.d/60-xubuntu.conf)
	then
	    writeToJason "Yes" "autologinstatus";
	else
		writeToJason "No" "autologinstatus";
		securityScore=$((securityScore+10))
	fi
	
	#Calculate scores
	#xP=$(id -u $LOGED_USER)
	if [[ $xP == *990* ]] 
	then
		securityScore=$((securityScore+10));
	else
	
		getSDA=$(lsblk|egrep crypt|cut -d _ -f 1| sed 's/[^a-zA-Z0-9]//g');	
		if [[ -n $getSDA ]] 
		then
			securityScore=$((securityScore+2));
			
			if (apt-mark showhold|grep cryptsetup-bin) 
			then					
				securityScore=$((securityScore+2));					
			fi
			
		fi
	fi
	
	SERVICE="KodachiBrowser";
	SERVICE2="firefox";
	if (ps ax | grep -v grep | grep $SERVICE| grep $SERVICE2> /dev/null)
	then
		securityScore=$((securityScore+10));
	fi
	
	
	
	
	# Set security model
	toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
	if [[ "$toriffy_Status" == *No* ]]
	then
		SERVICE='openvpn';
		if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
		then
		    SERVICE='tor-service';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				theModel="ISP->VPN->Tor";
				securityScore=$((securityScore+30))
				SERVICE='dnscrypt-proxy';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					theModel="ISP->VPN->Tor->DNScrypt";
					securityScore=$((securityScore+15))
				else
				dns_provider=$(cat $Jason_file_name | jq -r .DNSprovider);
				if [[ "$dns_provider" == TOR ]]
				then
					securityScore=$((securityScore+20))
					theModel="ISP->VPN->Tor->TorDNS";
				fi
				fi
				
			else
				SERVICE='dnscrypt-proxy';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					theModel="ISP->VPN->DNScrypt";
					securityScore=$((securityScore+35))
				else
					theModel="ISP->VPN";
					securityScore=$((securityScore+20))
				fi
			fi
		else
			theModel="ISP";
			SERVICE='dnscrypt-proxy';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				theModel="ISP->DNScrypt";
				securityScore=$((securityScore+15))
			else
			dns_provider=$(cat $Jason_file_name | jq -r .DNSprovider);
			if [[ "$dns_provider" == TOR ]]
			then
			    securityScore=$((securityScore+20))
				theModel="ISP->TorDNS";
			fi
			fi
			SERVICE='tor-service';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				theModel="ISP->Tor";
				securityScore=$((securityScore+10))
				SERVICE='dnscrypt-proxy';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					theModel="ISP->Tor->DNScrypt";
					securityScore=$((securityScore+15))
				else
				dns_provider=$(cat $Jason_file_name | jq -r .DNSprovider);
				if [[ "$dns_provider" == TOR ]]
				then
					securityScore=$((securityScore+20))
					theModel="ISP->Tor->TorDNS";
				fi
				fi
			fi
		fi
	else
		SERVICE='openvpn';
		if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
		then
			securityScore=$((securityScore+40))
			theModel="ISP->VPN->Torify";				 
			dns_provider=$(cat $Jason_file_name | jq -r .DNSprovider);
			if [[ "$dns_provider" == TOR ]]
			then
				theModel="ISP->VPN->Torify->TorDNS";
				securityScore=$((securityScore+20))
			fi
		else
			theModel="ISP->Torify";
			securityScore=$((securityScore+20))
			dns_provider=$(cat $Jason_file_name | jq -r .DNSprovider);
			if [[ "$dns_provider" == TOR ]]
			then
			    securityScore=$((securityScore+20))
				theModel="ISP->Torify->TorDNS";
			fi
		fi
	fi
		
	writeToJason "$theModel" "securitymodel";	
	
	# Check force via vpn stuff
	if [[ "$toriffy_Status" == *No* ]]
	then
	
		SERVICE='openvpn';
		if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
		then
			 								
			if(sudo ufw status |grep tun0 > /dev/null)
			then
				
				securityScore=$((securityScore+2));
			
			fi			
							
			myCard=$(cat $Jason_file_name | jq -r .netintused);
			if(sudo ufw status |grep $myCard > /dev/null)
			then
				
				securityScore=$((securityScore+2));
			
			fi
		fi				
			
	fi
	#end scurity model check
	
	# Print the score
    writeToJason "$securityScore" "securityscore";	
	
}
  

function mainwork_stop_vpn()
{
	# if we have stop vpn command
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);
	# Stop vpn service
	if [[ "$vpntype" == *Novpn* ]]
	then
		
		SERVICE='openvpn';
		if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
		then
		    
		 	SERVICE2='riseup-vpn';    
		    if (ps ax | grep -v grep | grep $SERVICE2 > /dev/null)
			then
				sudo killall riseup-vpn;
				sleep 1;
				timeout 2 sudo riseup-vpn -start-vpn off;
				sleep 1;
				sudo killall riseup-vpn ;
				sleep 1;
			fi
		    
		    echo "novpn command received I will stop vpn type:$vpntype";	 
			sudo killall -SIGINT openvpn;
			notify-send -i $notifyIcon "VPN is shutdown"; 	        
	        reset_VPN_IP;
	       
		
	        
	        run_tor_if_vpn_is_off=$(cat $Jason_file_name | jq -r .TORonifVPNison); 
			if  [[ "$run_tor_if_vpn_is_off" == *Yes* ]] 
			then
				echo "Restarting tor after stopping vpn";
				notify-send -i $notifyIcon "Restarting Tor after VPN shutdown";
				echo "check point tor stop 8";
				rand=$[$RANDOM % ${#arr[@]}]
				COuntryCode=${arr[$rand]};		
				print_error "Tor process was not found so let us restart it";
				reset_TOR_IP;
				sudo /etc/init.d/tor restart;
				sleep 3;
				# for some how some tor nodes are banned
				sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={$COuntryCode};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
				print_error "First try to switch TOR to: $COuntryCode";
				sleep 3;
				
			else
				dns_provider=$(cat $Jason_file_name | jq -r .DNSprovider);
				if [[ ! "$dns_provider" == TOR ]]
				then
					echo "Stopping tor after stopping vpn2";
					echo "check point tor stop 2";
					sudo /etc/init.d/tor stop;				
					reset_TOR_IP;
				fi
		
			
			fi
			
		
		   	writeToJason "1" "systemhealthactionpicker";	
			writeToJason "Disabled" "VPNtype";	
			
			toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
			if [[ "$toriffy_Status" == *Yes* ]]
			then
			
				sudo bash $Mykodachi_path/stoptor;
				reset_TOR_IP;
			
			fi
			securityStatus="notsecure";	
			writeToJason "$securityStatus" "SecurityStatus";			
		fi
		
		
		
		
	fi
	
	
}


function mainwork_TOR_Control()
{
	# Tor stuff
	#check if we have tor dns on
	dns_provider=$(cat $Jason_file_name | jq -r .DNSprovider);
	if [[ "$dns_provider" == TOR ]]
	then
		TorDNSison="Yes";
	else
		TorDNSison="No";		
	fi
	
	# If VPN is off kill tor 
	run_tor_if_vpn_is_off=$(cat $Jason_file_name | jq -r .TORonifVPNisoff);
	toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);	  
	if [[ "$run_tor_if_vpn_is_off" == *No* ]] 
	then
				
		#echo "tor is set to autotorvpn:$autotorvpn";
		SERVICE='openvpn';
		if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)
		then
			SERVICE='tor-service';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)			
			then
				toriffy_Status=$(cat $Jason_file_name | jq -r .Toriffystatus);
				if [[ "$dns_provider" == TOR ]] || [[ "$toriffy_Status" == *Yes* ]]
				then
					notify-send -i $notifyIcon "Tor DNS is on if you shutdown Tor you will loose Internet connection" \ "Please change to other DNS provider first" ;	
					writeToJason "Yes" "TORonifVPNisoff";	
					
				else
					SERVICE='tor-service';
					if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
					then
						echo "check point tor stop 1";
						sudo /etc/init.d/tor stop; 
						reset_TOR_IP;
						notify-send -i $notifyIcon "TOR has shutdown"; 				
						echo "stopping tor by stop tor command";						
					fi
				fi				
			fi					
		else
			torswitch=$(cat $Jason_file_name | jq -r .TORenabled);
			if [[ "$torswitch" == *Yes* ]]
			then
				SERVICE='tor-service';
				if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)			
				then
					echo "check point tor stop 2";
					sudo /etc/init.d/tor restart;
					reset_TOR_IP;		
					rand=$[$RANDOM % ${#arr[@]}]
					COuntryCode=${arr[$rand]};		
					print_error "Tor process was not found so let us restart it";
					reset_TOR_IP;
					sudo /etc/init.d/tor restart;
					sleep 3;
					# for some how some tor nodes are banned
					sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={$COuntryCode};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
					print_error "First try to switch TOR to: $COuntryCode";
					sleep 3;	
					
					# Wait for mr tor to be ready
					#waitForTor2beready;
					( cmdpid=$BASHPID; 
					(sleep 60; kill $cmdpid) \
					& while ! waitForTor2beready 
					 do 
					 echo "Tor wait termintated"; 
					done )		
				fi	
			fi	
		
		fi			
	else 
	    torswitch=$(cat $Jason_file_name | jq -r .TORenabled);
	    if [[ "$torswitch" == *Yes* ]]
	    then
			SERVICE='openvpn';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
			then
				SERVICE='tor-service';
				if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)			
				then
					echo "check point tor stop 3";
					rand=$[$RANDOM % ${#arr[@]}]
					COuntryCode=${arr[$rand]};		
					print_error "Tor process was not found so let us restart it";
					reset_TOR_IP;
					sudo /etc/init.d/tor restart;
					sleep 3;
					# for some how some tor nodes are banned
					sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={$COuntryCode};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
					print_error "First try to switch TOR to: $COuntryCode";
					sleep 3;
					# Wait for mr tor to be ready
					#waitForTor2beready;
					( cmdpid=$BASHPID; 
					(sleep 60; kill $cmdpid) \
					& while ! waitForTor2beready 
					 do 
					 echo "Tor wait termintated"; 
					done )	
											
				fi	
			else
				SERVICE='tor-service';
				if !(ps ax | grep -v grep | grep $SERVICE > /dev/null)			
				then
					echo "check point tor stop 4";
					rand=$[$RANDOM % ${#arr[@]}]
					COuntryCode=${arr[$rand]};		
					print_error "Tor process was not found so let us restart it";
					reset_TOR_IP;
					sudo /etc/init.d/tor restart;
					sleep 3;
					# for some how some tor nodes are banned
					sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={$COuntryCode};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
					print_error "First try to switch TOR to: $COuntryCode";
					sleep 3;
					
					
					# Wait for mr tor to be ready
					#waitForTor2beready;
					( cmdpid=$BASHPID; 
					(sleep 60; kill $cmdpid) \
					& while ! waitForTor2beready 
					 do 
					 echo "Tor wait termintated"; 
					done )		
				fi				
			fi	
		else
			SERVICE='tor-service';
			if (ps ax | grep -v grep | grep $SERVICE > /dev/null)			
			then
				echo "check point tor stop 5";
				sudo /etc/init.d/tor stop; 
				reset_TOR_IP;
				notify-send -i $notifyIcon "TOR has shutdown"; 				
				echo "stopping tor by stop tor command";
				
			fi
		
		fi
	
	fi
	
		
	
	# Check if tor is fake
	SERVICE='tor-service';
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)			
	then
		jTorip=$(cat $Jason_file_name | jq -r .TORIP);
		x=$(echo $jTorip|xargs);
		# If reply is valid ip address then accept the domain
		if [[ ! "$x" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]
		then
			tornullipcounter=$((tornullipcounter+1));
			if [[ $tornullipcounter -eq 15 ]]
			then
				# for some how some tor nodes are banned
				sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={ch};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
				print_error "Trying to switch TOR to Switzelend ch tornullipcounter is: $tornullipcounter";
			fi
			
			if [[ $tornullipcounter -eq 30 ]]
			then
				# for some how some tor nodes are banned
				sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={be};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
				print_error "Trying to switch TOR to belgium be tornullipcounter is: $tornullipcounter";
			fi
			
			if [[ $tornullipcounter -eq 45 ]]
			then
				print_error "We have issue with TOR no ip found will trouble shoot check99A";
				
				rand=$[$RANDOM % ${#arr[@]}]
				COuntryCode=${arr[$rand]};		
				print_error "Tor process was not found so let us restart it";
				reset_TOR_IP;
				sudo /etc/init.d/tor restart;
				sleep 3;
				# for some how some tor nodes are banned
				sudo bash $Mykodachi_path/torforce off|(echo authenticate '"Auo2@s3ks@Wdq"';echo SETCONF ExitNodes={$COuntryCode};echo SETCONF StrictNodes=1 ;echo signal newnym; echo quit) | nc localhost 9060
				print_error "First try to switch TOR to: $COuntryCode";
				sleep 3;
			    
				 
				 
				 # Wait for mr tor to be ready
				#waitForTor2beready;
				( cmdpid=$BASHPID; 
				(sleep 60; kill $cmdpid) \
				& while ! waitForTor2beready 
				 do 
					 echo "Tor wait termintated"; 
				 done )		
				 	
				
			fi
		
		else
			tornullipcounter=0;
		fi	
	fi  

 	

		
}





function mainwork_NO_net()
{
	
	
	
		
	#let it breath on start up
	#sleep 15;
   
	#while true; do
        #Set variables
        unset SERVICE;
        unset theModel;
        unset securityScore;
        securityScore=0;	
		
	    mainwork_NO_net_simple_tasks_repeated;
		mainwork_NO_net_scoring;		
		# Trouble shoot
		#notify-send -t 30000 -i $notifyIcon  "Calling no net wow $theIPcounter";
		  
		

	#done		
}




function mainwork_net_startup()
{
	
	# Lock the script so it does not run twice
	
	if [ ! -d $Mykodachi_path/tmp ]; then
		mkdir -p $Mykodachi_path/tmp;
		chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp;
	fi;
	
    #NEW_UUID=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
	NEW_UUID="W2ygSm9EdXbKkbqip7EtWwHdDYWkytai@net@";
	me=$(basename "$(test -L "$0" && readlink "$0" || echo "$0")");

	lockdir=$Mykodachi_path/tmp/$NEW_UUID$me;
	mkdir $lockdir || {
		echo "lock directory exists. exiting";
		exit 1
	}
	# take pains to remove lock directory when script terminates
	trap "rmdir $lockdir" EXIT INT KILL TERM; 

	# rest of script here
	sudo chown $LOGED_USER.$LOGED_USER $Mykodachi_path/tmp/$NEW_UUID$me;
	
	# end script locker
	
    #Disable num lock keyboard issues for someusers to check status 
	#xset q | grep "Num Lock"
	# You need sleep 30 before it which is above ^
	numlockx off


	# Reset json
	resetalljson;
	 
	
	actionpickervalue=0;
	writeToJason "$actionpickervalue" "systemhealthactionpicker";
	writeToJason "Stop" "healthsactionstatus"; 
	# give chance to dns control to start
    sleep 20; 
	
}

function get_ip_domain()
{
	
		randomdomain=$(cat $domainsFile | xargs shuf -n1 -e);
		echo "Ip domain:" $randomdomain;
		
		if [ ! -n $randomdomain ]
		then
			echo " Random domain was empty so we set digi77 domain";
			randomdomain=$(cat $Jason_web_file_name | jq -r '.ServerFeed2[].kodachiipcheck'|xargs);
		fi
		
		# Trim url for conky
		dO=$( echo $randomdomain| sed -e 's|^[^/]*//||' -e 's|/.*$||');    
		writeToJason "$dO" "Ipdomainsshorturl";	
		
				
		# If domain file is deleted
				 
		if [[ ! -f $domainsFile ]];  
		then
			ipsourcefile==$(cat $Jason_file_name | jq -r .Ipdomainsource);
			if [[ "$ipsourcefile" == *digi77* ]]
			then
					
				echo "Regular domain update ipsource=1 and we have net on digi setting Digi77";
				sudo bash $Mykodachi_path/ipcheck -a digi77;
				
				elif [[ "$ipsourcefile" == *other* ]]
			then
				echo "Regular domain update ipsource=0 and we havenet setting to other";
				sudo bash $Mykodachi_path/ipcheck -a other;	
			fi					
		fi # If domain file is deleted  
		
		
		
	

}


function mainwork_vpn_control()
{
	
	# Start Own VPN
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  			
	if [[ "$vpntype" == *Own* ]]
	then
		
		echo "my ip inside own vpn function is:" $permenet_VPN_IP
		
		SERVICE1='myownvpn.ovpn';
		SERVICE2='openvpn';				 
		if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
		then
			
			echo "Starting own vpn now";
			startvpnfunction;
			fetchallips;				
			vpn_timers;
		fi  
		    
	fi
	
	
	
	# Start Nord VPN
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  
	if [[ "$vpntype" == *Nord* ]]
	then
		
		echo "my ip inside Nord vpn function is:" $permenet_VPN_IP
		
		SERVICE1='vpnnordovpnfiles';
		SERVICE2='openvpn';				 
		if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
		then
			
			echo "Starting Nord vpn now";
			startvpnfunction;
			fetchallips;
			vpn_timers;				
		fi  
		    
	fi
	
	
	# Start hideme VPN
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  
	if [[ "$vpntype" == *Hideme* ]]
	then
		
		echo "my ip inside Hideme vpn function is:" $permenet_VPN_IP
		
		SERVICE1='vpnhidemeovpnfiles';
		SERVICE2='openvpn';				 
		if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
		then
			
			echo "Starting Hideme vpn now";
			startvpnfunction;
			fetchallips;
			vpn_timers;					
		fi  
		    
	fi
	
	# Start Proton VPN
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  
	if [[ "$vpntype" == *Proton* ]]
	then
		
		echo "my ip inside Proton vpn function is:" $permenet_VPN_IP
		
		SERVICE1='vpnprotonovpnfiles';
		SERVICE2='openvpn';				 
		if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
		then
			
			echo "Starting Proton vpn now";
			startvpnfunction;
			fetchallips;	
			vpn_timers;			
		fi  
		    
	fi
	
	
	# Start Vpngate
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  
	if [[ "$vpntype" == *Gate* ]]
	then
		
		echo "my ip inside VPN Gate  function is:" $permenet_VPN_IP
		
		SERVICE1='vpngateovpnfiles';
		SERVICE2='openvpn';				 
		if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
		then
			
			echo "Starting VPN Gate now";
			startvpnfunction;
			fetchallips;
			vpn_timers;			
		fi  
		    
	fi
	
	
   # Start Mullvad
    vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  
	if [[ "$vpntype" == *Mullvad* ]]
	then
		
		echo "my ip inside Mullvad  function is:" $permenet_VPN_IP
		
		SERVICE1='vpnpmullvadovpnfiles';
		SERVICE2='openvpn';				 
		if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
		then
			
			echo "Starting Mullvad now";
			startvpnfunction;
			fetchallips;	
			vpn_timers;		
		fi  
		    
	fi
	
	
	
	# Start Kern VPN
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  	
	if [[ "$vpntype" == *Kern* ]]
	then
		
		echo "my ip inside Kern VPN  function is:" $permenet_VPN_IP
		
		SERVICE1='vpnkernovpnfiles';
		SERVICE2='openvpn';				 
		if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
		then
			
			echo "Starting Kern VPN now";
			startvpnfunction;
			fetchallips;
			vpn_timers;
		
		fi  
		    
	fi
	
	
	# Start Rise
    vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  
	if [[ "$vpntype" == *Rise* ]]
	then
		
		echo "my ip inside Rise  function is:" $permenet_VPN_IP
		
		SERVICE1='LEAPOPENVPN';
		SERVICE2='openvpn';				 
		if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
		then
			
			echo "Starting Rise now";
			startvpnfunction;
			fetchallips;
			vpn_timers;			
		fi  
		    
	fi	


	# Start kodachi vpn
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  
	if [[ "$vpntype" == Kodachi ]]
	then
		 
		 if [[ "$Ban_Status" == *Banned* ]]
		then
			banAction; 	
		else
			SERVICE1='/etc/openvpn/kodachi-vpn.ovpn';
			SERVICE2='openvpn';				 
			if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
			then
						 
				startvpnfunction;					
				fetchallips;
				vpn_timers;					
			fi
			
			
		fi   
	fi
	
	
	
	# Start Kodachi-Anonymous vpn
	vpntype=$(cat $Jason_file_name | jq -r .VPNtype);  
	if [[ "$vpntype" == Kodachi-Anonymous ]]
	then
		 
		 if [[ "$Ban_Status" == *Banned* ]]
		then
			banAction; 	
		else
			SERVICE1='/etc/openvpn/kodachi-vpn-tor.ovpn';
			SERVICE2='openvpn';				 
			if !(ps ax | grep -v grep | grep $SERVICE1|grep $SERVICE2 > /dev/null)
			then
						 
				startvpnfunction;					
				fetchallips;	
				vpn_timers;				
			fi
			
			
		fi   
	fi
	
	
	
	
	
	# Check for fake vpn connection
    permenet_VPN_IP_check=$(cat $Jason_file_name | jq -r .VPNIP);  
    permenet_ISP_IP_check=$(cat $Jason_file_name | jq -r .OriginalISPIPAddress);  
    #echo "$permenet_VPN_IP_check / $permenet_ISP_IP_check";
    #sleep 10;
	# If we have same ip multi times disconnect vpn
	SERVICE='openvpn';				 
	if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
	then
		if [[ "$permenet_VPN_IP_check" == "$permenet_ISP_IP_check" ]]  && [[ $"permenet_ISP_IP_check" != "-" ]] 
		then
			sameipCounter=$((sameipCounter+1));
			fetchallips;	 
			echo "Found same ip for ISP and VPN counter:$sameipCounter";
		else
			sameipCounter=0;
		
		fi
		
		if [[ $sameipCounter == 10 ]]
		then
			notify-send -i $notifyIcon "ISP IP is same as VPN IP so VPN will be restarted" \ "ISP IP: $permenet_ISP_IP_check = VPN IP: $permenet_VPN_IP_check";
			sameipCounter=0;
			sameipCounter=0;
			sudo killall -SIGINT openvpn;			
			echo "Counter = 3 killed VPN";						
		fi
		
	fi
	
	
	
	
	
}




function mainwork_net()
{
	

	
	#let it breath on start up
	#sleep 5;	
	mainwork_net_startup;		
	 
	
			
	theIPcounter=0;  
	killVPNTorcounter=0
	
	# make sure we have internet before starting   
	netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
	if [[ $netStatustxt == *Online* ]]
	then
		# So VPN does not start before we have ISP iP :p
		if [[ $theIPcounter == 0 ]] 
		then
			get_ip_domain; 
			fetchallips;
		fi
	fi
		 
	while true; do
		writeToJason "Run" "healthsactionstatus"; 
		unset SERVICE;
		unset SERVICE2;
		vpn_timers;
			
		
		# Get the domain to be used
		get_ip_domain; 
		 
		
		actionpickervalue=$(cat $Jason_file_name | jq -r .systemhealthactionpicker);		
		if [[ $actionpickervalue == 1 ]]
		then
			#clear;
			echo "############# SOS action ##########";
		fi
		
		if [[ $theIPcounter == 0 ]]
		then
			#clear;
			echo "############# Baby born ##########";
			
		fi
		
		
		#if [[ $theIPcounter == 0 ]] || [[ $theIPcounter == 10 ]] || [[ $theIPcounter == 20 ]] || [[ $theIPcounter == 30 ]] || [[ $theIPcounter == 40 ]] || [[ $theIPcounter == 50 ]]
   	    # Run Ever mod = 2
		rem=$(( $theIPcounter % 2 )) 
		if [ $rem -eq 0 ] 
		then
	    
			writeToJason "Run" "healthsactionstatus"; 
			# Main no net taks
			print_good "Time to to do the  mainwork_NO_net works theIPcounter= $theIPcounter";
			mainwork_NO_net;
				
		fi # Every 10 sec regardless net condition
		
			    		 
		# make sure we have internet before starting   
		netStatustxt=$(cat $Jason_file_name | jq -r .InternetStatus);
		if [[ $netStatustxt == *Online* ]]
		then
			
					
			# So VPN does not start before we have ISP iP :p
			if [[ $theIPcounter == 0 ]] 
			then
				fetchallips;				
			fi
			
			if [[ $theIPcounter == 0 ]] || [[ $theIPcounter == 25 ]] || [[ $theIPcounter == 50 ]] 
			then
							  						
							
				writeToJason "Run" "healthsactionstatus"; 	
				#Get all vars from remote json to local json  
				print_good "Time to get remote json file  theIPcounter= $theIPcounter";
				getRemoteKodachijson;
																
													
				# Check if user is banned
				print_good "Time to get bans theIPcounter= $theIPcounter";
				getBan;
				
				
				#Check for updates
				print_good "Time to get remote updates theIPcounter= $theIPcounter";
				#checkRemoteUpdates;
				
								
				
			    
			fi   # Every 10 sec	with net					 
			 
		    			
		
			if [[ $theIPcounter -ge 0 ]]  # Run everytime
			then
			
				mainwork_vpn_control;	
				mainwork_stop_vpn;
				mainwork_TOR_Control;
								
				
				
				# Call ips if we have sos
				actionpickervalue=$(cat $Jason_file_name | jq -r .systemhealthactionpicker);
				if [[ "$actionpickervalue" == 1 ]]
				then
					echo "Calling ips picker is:$actionpickervalue"
					#sleep 5;									
					fetchallips;	     					
				fi
				
				
				# Domains file recovery method
				ipsourcefile==$(cat $Jason_file_name | jq -r .Ipdomainsource);
				if [[ "$ipsourcefile" == *other* ]]
				then
					 # If something wrong with other domain don't wait for counters
					mq=$(wc -l < $domainsFile)
					# If only we have less than 3 domains than we have an issue
					echo "Inside Emergency domain checker ";
					if [[ $mq -lt 3 ]]
					then						    
						echo "Regular domain update ipsource=0 and we have less than 3 lines:$mq";
						sudo bash $Mykodachi_path/ipcheck -a other;	
					else
					   echo "Skipping other domain checker lines:$mq";
					fi
				fi
				
				
				
				
				# Set conky bandwidth
				# BD eye				
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					upB=$(awk -v OFS=, '/tun0:/ { print $10, $2 }' /proc/net/dev|cut -d , -f 1);
					doB=$(awk -v OFS=, '/tun0:/ { print $10, $2 }' /proc/net/dev|cut -d , -f 2);
					echo "BDS: $upB and $doB";
					if [[ -n $upB ]] & [[ -n $doB ]]
					then
						
						#For Testing only
						#bmyown=2147483641;
						#bTota=$(($upB + $doB + $bmyown));
						
						bTota=$(($upB + $doB));
						bTotaConky=$(echo $bTota|awk '{$1=$1/(1024^3); print $1;}'); 
						bTotaConky=$(echo $bTotaConky|xargs printf "%.5f");
						writeToJason "$bTotaConky" "kodachivpnbandwidth";	
					else
						bTota=0;
					fi
				fi
			
		
			fi # Run Every time
			
			
			
		    # Run Ever mod = 2
			rem=$(( $theIPcounter % 2 )) 
			if [ $rem -eq 0 ] 
			then
			
				# update the ips		
				print_good "Time to fetch for ip addresess  theIPcounter= $theIPcounter";
				fetchallips;
				
				# Check bandwidth and warn the user
				SERVICE='openvpn';
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					
					
					#bTota=$(echo $bTota|awk '{$1=$1/(1024^2); print $1;}'|bc); 
					maxallowed2g=107374182400; # this is 100G from https://convertlive.com/u/convert/gigabytes/to/bytes#2
					maxallowed4g=214748364800; # 200 gb
					
					if [[ $bTota -gt $maxallowed2g ]]
					then
						vpntype=$(cat $Jason_file_name | jq -r .VPNtype);
						# Stop vpn service
						if [[ "$vpntype" == *Kodachi* ]]
						then
							SERVICE='openvpn';
							if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
							then
								notify-send -t 30000 -i $notifyIcon "Hay! You have consumed $bTotaConky of $OS_name VPN bandwidth so far 
$OS_name VPN is shared with others please slow down 
so you don't get blocked!";
								bash $Mykodachi_path/beeper > /dev/null 2>&1;
							fi
						fi
					else
						if [[ $bTota -gt $maxallowed4g ]]
						then							
							if [[ "$vpntype" == *Kodachi* ]]
							then
								SERVICE='openvpn';
								if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
								then
									notify-send -t 30000 -i $notifyIcon "Hay! You have consumed $bTotaConky of bandwidth so far 
	$OS_name VPN is shared with others please slow down 
	so you don't get blocked!
	stopping $OS_name VPN now please use your own VPN 
	or other free/paid choices available" ;
									bash $Mykodachi_path/beeper > /dev/null 2>&1;
									writeToJason "Novpn" "VPNtype";
									sudo killall -SIGINT openvpn;
									
								fi
							fi
						fi
					fi	
			    fi	
			
			fi # Run Ever mod = 2
			
			
			
			
			
				
			
			theIPcounter=$((theIPcounter+1));
			echo " End of net check counter is:" $theIPcounter
			if [ $theIPcounter -ge 60 ] ; then
				theIPcounter=0;
				echo "Reseting the counter to 0 from $theIPcounter";
			fi
   
			killVPNTorcounter=0;			   
			killVPNTorcounterpopup=0;
			
			
			# if we have a command from user don't sleep 
			actionpickervalue=$(cat $Jason_file_name | jq -r .systemhealthactionpicker);
			randomSleeper=$((RANDOM %15));
			while :
			do
				
				# Run Ever mod = 2
				rem=$(( $theIPcounter % 2 )) 				
				if [[ "$actionpickervalue" == 0 ]] && [[ $rem -eq 0 ]]
				then
					echo " %%% Going to sleep we have net for $randomSleeper sec actionpickervalue:$actionpickervalue theIPcounter:$theIPcounter holdtimer:$holdTimer";
					if [ $holdTimer == 0 ]
					then
						writeToJason "Stop" "healthsactionstatus";
					fi
					sleep 1;
					
					if [ $holdTimer -ge $randomSleeper ]
					then
						
						echo "Online pause I have been sleeping for $randomSleeper sec time to break";
						actionpickervalue=0;
						writeToJason "$actionpickervalue" "systemhealthactionpicker";
						holdTimer=0;
						break
					fi	
				else
					echo "Online pause I am active action value is: $actionpickervalue";
					actionpickervalue=0;
					writeToJason "$actionpickervalue" "systemhealthactionpicker";
					break
				fi	
				holdTimer=$((holdTimer+1));	
				 
			done 
			
			
			
			
		else  # Offline #
			##### No NET actions####
		   	killVPNTorcounter=$((killVPNTorcounter+1))  
			echo " xxxxxxxx We are offline xxxxxxx";
			theIPcounter=0; 
						
			
			if [ $killVPNTorcounter = 30 ]; 
			then
				SERVICE='openvpn';				 
				if (ps ax | grep -v grep | grep $SERVICE > /dev/null)
				then
					echo "No net trigger kill vpn and tor"
					sudo killall -SIGINT openvpn;
					reset_VPN_IP;
					run_tor_if_vpn_is_off=$(cat $Jason_file_name | jq -r .TORonifVPNisoff);
									
					if [[ "$run_tor_if_vpn_is_off" == *No* ]]
					then
						echo "check point tor stop 4";
						sudo /etc/init.d/tor stop;
						reset_TOR_IP;
					fi
					killVPNTorcounter=0;
				fi	
				
			fi
			
			
			killVPNTorcounterpopup=$(($killVPNTorcounterpopup+1))
			echo "Network fix popup counter: $killVPNTorcounterpopup";
			if [ $killVPNTorcounterpopup = 60 ]; then				
				
				#Maybe will use it again in future 
				#timeout 60 xfce4-terminal -e 'bash -c "sudo bash ~/.kbase/recovernetworkpopup; bash"' -T "Internet recovery"
				if (ifconfig|grep UP > /dev/null 2>&1)
				then
					notify-send -i $notifyIcon "Internet connection lost you can try to recover it by going to:
Panic room menu then -> Repair Network"; 
				fi
				killVPNTorcounterpopup=0;				
			fi
		    
			# if we have a command from user don't sleep 
			randomSleeper=$((RANDOM %5));
			actionpickervalue=$(cat $Jason_file_name | jq -r .systemhealthactionpicker);
			while :
			do
			
											
				if [[ "$actionpickervalue" == 0 ]]  
				then
					if [ $holdTimer == 0 ]
					then
						writeToJason "Stop" "healthsactionstatus";
					fi
					
					echo " %%% Going to sleep we are offline for $randomSleeper sec actionpickervalue:$actionpickervalue theIPcounter:$theIPcounter holdtimer:$holdTimer";
					sleep 1;
					if [ $holdTimer -ge $randomSleeper ]
					then
						
						echo "Offline pause I have been sleeping for $randomSleeper sec time to break";
						actionpickervalue=0;
						writeToJason "$actionpickervalue" "systemhealthactionpicker";
						holdTimer=0;
						break
					fi	
				else
					echo "Offline pause I am active action value is: $actionpickervalue";
					actionpickervalue=0;
					writeToJason "$actionpickervalue" "systemhealthactionpicker";
					break
				fi	
				holdTimer=$((holdTimer+1));	
				 
			done 	
			 
			
		fi # for net check
	

 
     
 
		
		writeToJason "Stop" "healthsactionstatus"; 
		
		
		
		
			    
	    
	    #if [[ $theIPcounter == 30 ]] 
		#then
			#randomSleeper=$((RANDOM %5));
			#sleep $randomSleeper;
			#print_good "## End of loop going went for a random sleep for: $randomSleeper s";
		#fi
		
		
		
	 
	done	
}






  
 






# Call the proper function
if [[ "$param1" == *normalspeed* ]]
then   
  
	mainwork_net;
	
elif [[ "$param1" == *fasttrack* ]]
then

	echo "Going in fast track";

fi
